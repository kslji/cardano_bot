import { BlockFrostAPI } from '@blockfrost/blockfrost-js';
import { PaginationOptions } from '@blockfrost/blockfrost-js/lib/types';
import Big from 'big.js';
import { Constr, Data, Address, Script, OutRef, Credential, UTxO, Lucid, TxComplete, Tx } from 'lucid-cardano';

declare const ADA: Asset;
declare type Asset = {
    policyId: string;
    tokenName: string;
};
declare namespace Asset {
    function fromString(s: string): Asset;
    function toString(asset: Asset): string;
    function toPlutusData(asset: Asset): Constr<Data>;
    function fromPlutusData(data: Constr<Data>): Asset;
    function compare(a1: Asset, a2: Asset): number;
    function equals(a1: Asset, a2: Asset): boolean;
}

declare enum NetworkId {
    TESTNET = 0,
    MAINNET = 1
}
declare enum NetworkEnvironment {
    MAINNET = 764824073,
    TESTNET_PREVIEW = 2,
    TESTNET_PREPROD = 1
}

declare type Value = {
    unit: string;
    quantity: string;
}[];
declare type TxIn = {
    txHash: string;
    index: number;
};
declare type TxHistory = {
    txHash: string;
    /** Transaction index within the block */
    txIndex: number;
    blockHeight: number;
    time: Date;
};

declare namespace FactoryV2 {
    type Datum = {
        head: string;
        tail: string;
    };
    namespace Datum {
        function toPlutusData(datum: Datum): Constr<Data>;
        function fromPlutusData(data: Constr<Data>): Datum;
    }
    type Redeemer = {
        assetA: Asset;
        assetB: Asset;
    };
    namespace Redeemer {
        function toPlutusData(redeemer: Redeemer): Constr<Data>;
        function fromPlutusData(data: Constr<Data>): Redeemer;
    }
    class State {
        readonly address: string;
        readonly txIn: TxIn;
        readonly value: Value;
        readonly datumCbor: string;
        readonly datum: Datum;
        constructor(networkId: NetworkId, address: string, txIn: TxIn, value: Value, datum: string);
        get head(): string;
        get tail(): string;
    }
}

declare namespace DexV1Constant {
    const ORDER_BASE_ADDRESS: Record<number, Address>;
    const POOL_SCRIPT_HASH = "script1uychk9f04tqngfhx4qlqdlug5ntzen3uzc62kzj7cyesjk0d9me";
    const FACTORY_POLICY_ID = "13aa2accf2e1561723aa26871e071fdf32c867cff7e7d50ad470d62f";
    const FACTORY_ASSET_NAME = "4d494e53574150";
    const LP_POLICY_ID = "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86";
    const POOL_NFT_POLICY_ID = "0be55d262b29f564998ff81efe21bdc0022621c12f15af08d0f2ddb1";
    const ORDER_SCRIPT: Script;
}
declare namespace StableswapConstant {
    type Config = {
        orderAddress: Address;
        poolAddress: Address;
        nftAsset: string;
        lpAsset: string;
        assets: string[];
        multiples: bigint[];
        fee: bigint;
        adminFee: bigint;
        feeDenominator: bigint;
    };
    type DeployedScripts = {
        order: OutRef;
        pool: OutRef;
        lp: OutRef;
        poolBatching: OutRef;
    };
    const CONFIG: Record<NetworkId, Config[]>;
    const DEPLOYED_SCRIPTS: Record<NetworkId, Record<string, DeployedScripts>>;
}
declare namespace DexV2Constant {
    type Config = {
        factoryAsset: string;
        poolAuthenAsset: string;
        globalSettingAsset: string;
        lpPolicyId: string;
        globalSettingScriptHash: string;
        globalSettingScriptHashBech32: string;
        orderScriptHash: string;
        poolScriptHash: string;
        poolScriptHashBech32: string;
        poolCreationAddress: Address;
        factoryScriptHashBech32: string;
        factoryScriptHash: string;
        factoryAddress: string;
        expiredOrderCancelAddress: string;
        poolBatchingAddress: string;
        orderEnterpriseAddress: string;
    };
    type DeployedScripts = {
        order: OutRef;
        pool: OutRef;
        factory: OutRef;
        authen: OutRef;
        poolBatching: OutRef;
        expiredOrderCancellation: OutRef;
    };
    const CONFIG: Record<NetworkId, Config>;
    const DEPLOYED_SCRIPTS: Record<NetworkId, DeployedScripts>;
}
declare enum MetadataMessage {
    DEPOSIT_ORDER = "SDK Minswap: Deposit Order",
    CANCEL_ORDER = "SDK Minswap: Cancel Order",
    ZAP_IN_ORDER = "SDK Minswap: Zap Order",
    ZAP_OUT_ORDER = "SDK Minswap: Zap Out Order",
    SWAP_EXACT_IN_ORDER = "SDK Minswap: Swap Exact In Order",
    SWAP_EXACT_IN_LIMIT_ORDER = "SDK Minswap: Swap Exact In Limit Order",
    SWAP_EXACT_OUT_ORDER = "SDK Minswap: Swap Exact Out Order",
    WITHDRAW_ORDER = "SDK Minswap: Withdraw Order",
    STOP_ORDER = "SDK Minswap: Stop Order",
    OCO_ORDER = "SDK Minswap: OCO Order",
    ROUTING_ORDER = "SDK Minswap: Routing Order",
    PARTIAL_SWAP_ORDER = "SDK Minswap: Partial Fill Order",
    DONATION_ORDER = "Minswap: Donation Order",
    MIXED_ORDERS = "SDK Minswap: Mixed Orders",
    CREATE_POOL = "SDK Minswap: Create Pool"
}
declare const FIXED_DEPOSIT_ADA = 2000000n;

declare type PoolFeeSharing = {
    feeTo: Address;
    feeToDatumHash?: string;
};
declare namespace PoolFeeSharing {
    function toPlutusData(feeSharing: PoolFeeSharing): Constr<Data>;
    function fromPlutusData(networkId: NetworkId, data: Constr<Data>): PoolFeeSharing;
}

declare const DEFAULT_POOL_V2_TRADING_FEE_DENOMINATOR = 10000n;
declare namespace PoolV1 {
    /**
     * Represents state of a pool UTxO. The state could be latest state or a historical state.
     */
    class State {
        /** The transaction hash and output index of the pool UTxO */
        readonly address: string;
        readonly txIn: TxIn;
        readonly value: Value;
        readonly datumHash: string;
        readonly assetA: string;
        readonly assetB: string;
        constructor(address: string, txIn: TxIn, value: Value, datumHash: string);
        get nft(): string;
        get id(): string;
        get assetLP(): string;
        get reserveA(): bigint;
        get reserveB(): bigint;
    }
    type Datum = {
        assetA: Asset;
        assetB: Asset;
        totalLiquidity: bigint;
        rootKLast: bigint;
        feeSharing?: PoolFeeSharing;
    };
    namespace Datum {
        function toPlutusData(datum: Datum): Constr<Data>;
        function fromPlutusData(networkId: NetworkId, data: Constr<Data>): Datum;
    }
}
declare namespace StablePool {
    class State {
        readonly address: string;
        readonly txIn: TxIn;
        readonly value: Value;
        readonly datumCbor: string;
        readonly datum: Datum;
        readonly config: StableswapConstant.Config;
        constructor(networkId: NetworkId, address: string, txIn: TxIn, value: Value, datum: string);
        get assets(): string[];
        get nft(): string;
        get lpAsset(): string;
        get reserves(): bigint[];
        get totalLiquidity(): bigint;
        get orderHash(): string;
        get amp(): bigint;
        get id(): string;
    }
    type Datum = {
        balances: bigint[];
        totalLiquidity: bigint;
        amplificationCoefficient: bigint;
        orderHash: string;
    };
    namespace Datum {
        function toPlutusData(datum: Datum): Constr<Data>;
        function fromPlutusData(data: Constr<Data>): Datum;
    }
}
declare namespace PoolV2 {
    const MAX_LIQUIDITY = 9223372036854775807n;
    const DEFAULT_POOL_ADA = 4500000n;
    const MINIMUM_LIQUIDITY = 10n;
    const DEFAULT_TRADING_FEE_DENOMINATOR = 10000n;
    function computeLPAssetName(assetA: Asset, assetB: Asset): string;
    type Info = {
        datumReserves: [bigint, bigint];
        valueReserves: [bigint, bigint];
        totalLiquidity: bigint;
        tradingFee: {
            feeANumerator: bigint;
            feeBNumerator: bigint;
        };
        feeSharingNumerator?: bigint;
    };
    class State {
        readonly address: string;
        readonly txIn: TxIn;
        readonly value: Value;
        readonly datumRaw: string;
        readonly datum: Datum;
        readonly config: DexV2Constant.Config;
        readonly lpAsset: Asset;
        readonly authenAsset: Asset;
        constructor(networkId: NetworkId, address: string, txIn: TxIn, value: Value, datum: string);
        get assetA(): string;
        get assetB(): string;
        get totalLiquidity(): bigint;
        get reserveA(): bigint;
        get reserveB(): bigint;
        get feeA(): [bigint, bigint];
        get feeB(): [bigint, bigint];
        get feeShare(): [bigint, bigint] | undefined;
        get datumReserves(): [bigint, bigint];
        get valueReserveA(): bigint;
        get valueReserveB(): bigint;
        get valueReserves(): [bigint, bigint];
        get info(): Info;
    }
    type Datum = {
        poolBatchingStakeCredential: Credential;
        assetA: Asset;
        assetB: Asset;
        totalLiquidity: bigint;
        reserveA: bigint;
        reserveB: bigint;
        baseFee: {
            feeANumerator: bigint;
            feeBNumerator: bigint;
        };
        feeSharingNumerator?: bigint;
        allowDynamicFee: boolean;
    };
    namespace Datum {
        function toPlutusData(datum: Datum): Constr<Data>;
        function fromPlutusData(data: Constr<Data>): Datum;
    }
}

declare type BlockfrostAdapterOptions = {
    networkId: NetworkId;
    blockFrost: BlockFrostAPI;
};
declare type GetPoolsParams = Omit<PaginationOptions, "page"> & {
    page: number;
};
declare type GetPoolByIdParams = {
    id: string;
};
declare type GetPoolPriceParams = {
    pool: PoolV1.State;
    decimalsA?: number;
    decimalsB?: number;
};
declare type GetV2PoolPriceParams = {
    pool: PoolV2.State;
    decimalsA?: number;
    decimalsB?: number;
};
declare type GetPoolHistoryParams = PaginationOptions & {
    id: string;
};
declare type GetPoolInTxParams = {
    txHash: string;
};
declare type GetStablePoolInTxParams = {
    networkId: NetworkId;
    txHash: string;
};
declare class BlockfrostAdapter {
    private readonly api;
    private readonly networkId;
    constructor({ networkId, blockFrost }: BlockfrostAdapterOptions);
    /**
     * @returns The latest pools or empty array if current page is after last page
     */
    getV1Pools({ page, count, order, }: GetPoolsParams): Promise<PoolV1.State[]>;
    /**
     * Get a specific pool by its ID.
     * @param {Object} params - The parameters.
     * @param {string} params.pool - The pool ID. This is the asset name of a pool's NFT and LP tokens. It can also be acquired by calling pool.id.
     * @returns {PoolV1.State | null} - Returns the pool or null if not found.
     */
    getV1PoolById({ id, }: GetPoolByIdParams): Promise<PoolV1.State | null>;
    getV1PoolHistory({ id, page, count, order, }: GetPoolHistoryParams): Promise<TxHistory[]>;
    /**
     * Get pool state in a transaction.
     * @param {Object} params - The parameters.
     * @param {string} params.txHash - The transaction hash containing pool output. One of the way to acquire is by calling getPoolHistory.
     * @returns {PoolV1.State} - Returns the pool state or null if the transaction doesn't contain pool.
     */
    getV1PoolInTx({ txHash, }: GetPoolInTxParams): Promise<PoolV1.State | null>;
    getAssetDecimals(asset: string): Promise<number>;
    /**
     * Get pool price.
     * @param {Object} params - The parameters to calculate pool price.
     * @param {string} params.pool - The pool we want to get price.
     * @param {string} [params.decimalsA] - The decimals of assetA in pool, if undefined then query from Blockfrost.
     * @param {string} [params.decimalsB] - The decimals of assetB in pool, if undefined then query from Blockfrost.
     * @returns {[string, string]} - Returns a pair of asset A/B price and B/A price, adjusted to decimals.
     */
    getV1PoolPrice({ pool, decimalsA, decimalsB, }: GetPoolPriceParams): Promise<[Big, Big]>;
    getDatumByDatumHash(datumHash: string): Promise<string>;
    getAllV2Pools(): Promise<{
        pools: PoolV2.State[];
        errors: unknown[];
    }>;
    getV2Pools({ page, count, order, }: GetPoolsParams): Promise<{
        pools: PoolV2.State[];
        errors: unknown[];
    }>;
    getV2PoolByPair(assetA: Asset, assetB: Asset): Promise<PoolV2.State | null>;
    getV2PoolByLp(lpAsset: Asset): Promise<PoolV2.State | null>;
    /**
     * Get pool price.
     * @param {Object} params - The parameters to calculate pool price.
     * @param {string} params.pool - The pool we want to get price.
     * @param {string} [params.decimalsA] - The decimals of assetA in pool, if undefined then query from Blockfrost.
     * @param {string} [params.decimalsB] - The decimals of assetB in pool, if undefined then query from Blockfrost.
     * @returns {[string, string]} - Returns a pair of asset A/B price and B/A price, adjusted to decimals.
     */
    getV2PoolPrice({ pool, decimalsA, decimalsB, }: GetV2PoolPriceParams): Promise<[Big, Big]>;
    getAllStablePools(): Promise<{
        pools: StablePool.State[];
        errors: unknown[];
    }>;
    getStablePoolByNFT(nft: Asset): Promise<StablePool.State | null>;
    getAllFactoriesV2(): Promise<{
        factories: FactoryV2.State[];
        errors: unknown[];
    }>;
    getFactoryV2ByPair(assetA: Asset, assetB: Asset): Promise<FactoryV2.State | null>;
}

declare namespace OrderV1 {
    enum StepType {
        SWAP_EXACT_IN = 0,
        SWAP_EXACT_OUT = 1,
        DEPOSIT = 2,
        WITHDRAW = 3,
        ZAP_IN = 4
    }
    type SwapExactIn = {
        type: StepType.SWAP_EXACT_IN;
        desiredAsset: Asset;
        minimumReceived: bigint;
    };
    type SwapExactOut = {
        type: StepType.SWAP_EXACT_OUT;
        desiredAsset: Asset;
        expectedReceived: bigint;
    };
    type Deposit = {
        type: StepType.DEPOSIT;
        minimumLP: bigint;
    };
    type Withdraw = {
        type: StepType.WITHDRAW;
        minimumAssetA: bigint;
        minimumAssetB: bigint;
    };
    type ZapIn = {
        type: StepType.ZAP_IN;
        desiredAsset: Asset;
        minimumLP: bigint;
    };
    type Step = SwapExactIn | SwapExactOut | Deposit | Withdraw | ZapIn;
    type Datum = {
        sender: Address;
        receiver: Address;
        receiverDatumHash?: string;
        step: Step;
        batcherFee: bigint;
        depositADA: bigint;
    };
    namespace Datum {
        function toPlutusData(datum: Datum): Constr<Data>;
        function fromPlutusData(networkId: NetworkId, data: Constr<Data>): Datum;
    }
    enum Redeemer {
        APPLY_ORDER = 0,
        CANCEL_ORDER = 1
    }
}
declare namespace StableOrder {
    enum StepType {
        SWAP = 0,
        DEPOSIT = 1,
        WITHDRAW = 2,
        WITHDRAW_IMBALANCE = 3,
        ZAP_OUT = 4
    }
    type SwapStep = {
        type: StepType.SWAP;
        assetInIndex: bigint;
        assetOutIndex: bigint;
        minimumAssetOut: bigint;
    };
    type DepositStep = {
        type: StepType.DEPOSIT;
        minimumLP: bigint;
    };
    type WithdrawStep = {
        type: StepType.WITHDRAW;
        minimumAmounts: bigint[];
    };
    type WithdrawImbalanceStep = {
        type: StepType.WITHDRAW_IMBALANCE;
        withdrawAmounts: bigint[];
    };
    type ZapOutStep = {
        type: StepType.ZAP_OUT;
        assetOutIndex: bigint;
        minimumAssetOut: bigint;
    };
    type Step = SwapStep | DepositStep | WithdrawStep | WithdrawImbalanceStep | ZapOutStep;
    type Datum = {
        sender: Address;
        receiver: Address;
        receiverDatumHash?: string;
        step: Step;
        batcherFee: bigint;
        depositADA: bigint;
    };
    namespace Datum {
        function toPlutusData(datum: Datum): Constr<Data>;
        function fromPlutusData(networkId: NetworkId, data: Constr<Data>): Datum;
    }
    enum Redeemer {
        APPLY_ORDER = 0,
        CANCEL_ORDER = 1
    }
}
declare namespace OrderV2 {
    enum AuthorizationMethodType {
        SIGNATURE = 0,
        SPEND_SCRIPT = 1,
        WITHDRAW_SCRIPT = 2,
        MINT_SCRIPT = 3
    }
    type AuthorizationMethod = {
        type: AuthorizationMethodType;
        hash: string;
    };
    namespace AuthorizationMethod {
        function fromPlutusData(data: Constr<Data>): AuthorizationMethod;
        function toPlutusData(method: AuthorizationMethod): Constr<Data>;
    }
    enum Direction {
        B_TO_A = 0,
        A_TO_B = 1
    }
    namespace Direction {
        function fromPlutusData(data: Constr<Data>): Direction;
        function toPlutusData(direction: Direction): Constr<Data>;
    }
    enum Killable {
        PENDING_ON_FAILED = 0,
        KILL_ON_FAILED = 1
    }
    namespace Killable {
        function fromPlutusData(data: Constr<Data>): Killable;
        function toPlutusData(killable: Killable): Constr<Data>;
    }
    enum AmountType {
        SPECIFIC_AMOUNT = 0,
        ALL = 1
    }
    type DepositAmount = {
        type: AmountType.SPECIFIC_AMOUNT;
        depositAmountA: bigint;
        depositAmountB: bigint;
    } | {
        type: AmountType.ALL;
        deductedAmountA: bigint;
        deductedAmountB: bigint;
    };
    namespace DepositAmount {
        function fromPlutusData(data: Constr<Data>): DepositAmount;
        function toPlutusData(amount: DepositAmount): Constr<Data>;
    }
    type SwapAmount = {
        type: AmountType.SPECIFIC_AMOUNT;
        swapAmount: bigint;
    } | {
        type: AmountType.ALL;
        deductedAmount: bigint;
    };
    namespace SwapAmount {
        function fromPlutusData(data: Constr<Data>): SwapAmount;
        function toPlutusData(amount: SwapAmount): Constr<Data>;
    }
    type WithdrawAmount = {
        type: AmountType.SPECIFIC_AMOUNT;
        withdrawalLPAmount: bigint;
    } | {
        type: AmountType.ALL;
        deductedLPAmount: bigint;
    };
    namespace WithdrawAmount {
        function fromPlutusData(data: Constr<Data>): WithdrawAmount;
        function toPlutusData(amount: WithdrawAmount): Constr<Data>;
    }
    type Route = {
        lpAsset: Asset;
        direction: Direction;
    };
    namespace Route {
        function fromPlutusData(data: Constr<Data>): Route;
        function toPlutusData(route: Route): Constr<Data>;
    }
    enum StepType {
        SWAP_EXACT_IN = 0,
        STOP = 1,
        OCO = 2,
        SWAP_EXACT_OUT = 3,
        DEPOSIT = 4,
        WITHDRAW = 5,
        ZAP_OUT = 6,
        PARTIAL_SWAP = 7,
        WITHDRAW_IMBALANCE = 8,
        SWAP_ROUTING = 9,
        DONATION = 10
    }
    type SwapExactIn = {
        type: StepType.SWAP_EXACT_IN;
        direction: Direction;
        swapAmount: SwapAmount;
        minimumReceived: bigint;
        killable: Killable;
    };
    type Stop = {
        type: StepType.STOP;
        direction: Direction;
        swapAmount: SwapAmount;
        stopReceived: bigint;
    };
    type OCO = {
        type: StepType.OCO;
        direction: Direction;
        swapAmount: SwapAmount;
        minimumReceived: bigint;
        stopReceived: bigint;
    };
    type SwapExactOut = {
        type: StepType.SWAP_EXACT_OUT;
        direction: Direction;
        maximumSwapAmount: SwapAmount;
        expectedReceived: bigint;
        killable: Killable;
    };
    type Deposit = {
        type: StepType.DEPOSIT;
        depositAmount: DepositAmount;
        minimumLP: bigint;
        killable: Killable;
    };
    type Withdraw = {
        type: StepType.WITHDRAW;
        withdrawalAmount: WithdrawAmount;
        minimumAssetA: bigint;
        minimumAssetB: bigint;
        killable: Killable;
    };
    type ZapOut = {
        type: StepType.ZAP_OUT;
        direction: Direction;
        withdrawalAmount: WithdrawAmount;
        minimumReceived: bigint;
        killable: Killable;
    };
    type PartialSwap = {
        type: StepType.PARTIAL_SWAP;
        direction: Direction;
        totalSwapAmount: bigint;
        ioRatioNumerator: bigint;
        ioRatioDenominator: bigint;
        hops: bigint;
        minimumSwapAmountRequired: bigint;
        maxBatcherFeeEachTime: bigint;
    };
    type WithdrawImbalance = {
        type: StepType.WITHDRAW_IMBALANCE;
        withdrawalAmount: WithdrawAmount;
        ratioAssetA: bigint;
        ratioAssetB: bigint;
        minimumAssetA: bigint;
        killable: Killable;
    };
    type SwapRouting = {
        type: StepType.SWAP_ROUTING;
        routings: Route[];
        swapAmount: SwapAmount;
        minimumReceived: bigint;
    };
    type Donation = {
        type: StepType.DONATION;
    };
    type Step = SwapExactIn | Stop | OCO | SwapExactOut | Deposit | Withdraw | ZapOut | PartialSwap | WithdrawImbalance | SwapRouting | Donation;
    namespace Step {
        function fromPlutusData(data: Constr<Data>): Step;
        function toPlutusData(step: Step): Constr<Data>;
    }
    type ExpirySetting = {
        expiredTime: bigint;
        maxCancellationTip: bigint;
    };
    enum ExtraDatumType {
        NO_DATUM = 0,
        DATUM_HASH = 1,
        INLINE_DATUM = 2
    }
    type ExtraDatum = {
        type: ExtraDatumType.NO_DATUM;
    } | {
        type: ExtraDatumType.DATUM_HASH | ExtraDatumType.INLINE_DATUM;
        hash: string;
    };
    namespace ExtraDatum {
        function fromPlutusData(data: Constr<Data>): ExtraDatum;
        function toPlutusData(extraDatum: ExtraDatum): Constr<Data>;
    }
    type Datum = {
        canceller: AuthorizationMethod;
        refundReceiver: Address;
        refundReceiverDatum: ExtraDatum;
        successReceiver: Address;
        successReceiverDatum: ExtraDatum;
        lpAsset: Asset;
        step: Step;
        maxBatcherFee: bigint;
        expiredOptions?: ExpirySetting;
    };
    namespace Datum {
        function fromPlutusData(networkId: NetworkId, data: Constr<Data>): Datum;
        function toPlutusData(datum: Datum): Constr<Data>;
    }
    enum Redeemer {
        APPLY_ORDER = 0,
        CANCEL_ORDER_BY_OWNER = 1,
        CANCEL_EXPIRED_ORDER_BY_ANYONE = 2
    }
}

/**
 * Options to calculate Amount Out & Price Impact while swapping exact in
 * @amountIn The amount that we want to swap from
 * @reserveIn The Reserve of Asset In in Liquidity Pool
 * @reserveOut The Reserve of Asset Out in Liquidity Pool
 */
declare type CalculateSwapExactInOptions = {
    amountIn: bigint;
    reserveIn: bigint;
    reserveOut: bigint;
};
/**
 * Calculate Amount Out & Price Impact while swapping exact in
 * @param options See @CalculateSwapExactInOptions description
 * @returns The amount of the other token that we get from the swap and its price impact
 */
declare function calculateSwapExactIn(options: CalculateSwapExactInOptions): {
    amountOut: bigint;
    priceImpact: Big;
};
/**
 * Options to calculate necessary Amount In & Price Impact to cover the @exactAmountOut while swapping exact out
 * @exactAmountOut The exact amount that we want to receive
 * @reserveIn The Reserve of Asset In in Liquidity Pool
 * @reserveOut The Reserve of Asset Out in Liquidity Pool
 */
declare type CalculateSwapExactOutOptions = {
    exactAmountOut: bigint;
    reserveIn: bigint;
    reserveOut: bigint;
};
/**
 * Calculate necessary Amount In & Price Impact to cover the @exactAmountOut while swapping exact out
 * @param options See @CalculateSwapExactOutOptions description
 * @returns The amount needed of the input token for the swap and its price impact
 */
declare function calculateSwapExactOut(options: CalculateSwapExactOutOptions): {
    amountIn: bigint;
    priceImpact: Big;
};
/**
 * Options to calculate LP Amount while depositing
 * @depositedAmountA Amount of Asset A you want to deposit
 * @depositedAmountB Amount of Asset B you want to deposit
 * @reserveA Reserve of Asset A in Liquidity Pool
 * @reserveB Reserve of Asset B in Liquidity Pool
 * @totalLiquidity Total Circulating of LP Token in Liquidity Pool
 */
declare type CalculateDepositOptions = {
    depositedAmountA: bigint;
    depositedAmountB: bigint;
    reserveA: bigint;
    reserveB: bigint;
    totalLiquidity: bigint;
};
/**
 * Calculate LP Amount while depositing
 * @param options See @CalculateDepositOptions description
 * @returns The amount needed of Asset A and Asset and LP Token Amount you will receive
 */
declare function calculateDeposit(options: CalculateDepositOptions): {
    necessaryAmountA: bigint;
    necessaryAmountB: bigint;
    lpAmount: bigint;
};
/**
 * Options to calculate amount A and amount B after withdrawing @withdrawalLPAmount out of Liquidity Pool
 * @withdrawalLPAmount LP Token amount you want to withdraw
 * @reserveA Reserve of Asset A in Liquidity Pool
 * @reserveB Reserve of Asset B in Liquidity Pool
 * @totalLiquidity Total Circulating of LP Token in Liquidity Pool
 */
declare type CalculateWithdrawOptions = {
    withdrawalLPAmount: bigint;
    reserveA: bigint;
    reserveB: bigint;
    totalLiquidity: bigint;
};
/**
 * Calculate amount A and amount B after withdrawing @withdrawalLPAmount out of Liquidity Pool
 * @param options See @CalculateWithdrawOptions description
 * @returns amount A and amount B you will receive
 */
declare function calculateWithdraw(options: CalculateWithdrawOptions): {
    amountAReceive: bigint;
    amountBReceive: bigint;
};
/**
 * Options to calculate LP Amount while zapping
 * @amountIn Amount you want to zap
 * @reserveIn Reserve of Asset which you want to zap in Liquidity Pool
 * @reserveOut Reserve of other Asset in Liquidity Pool
 * @totalLiquidity Total Circulating of LP Token in Liquidity Pool
 */
declare type CalculateZapInOptions = {
    amountIn: bigint;
    reserveIn: bigint;
    reserveOut: bigint;
    totalLiquidity: bigint;
};
/**
 * Calculate LP Amount while zapping
 * @param options See @CalculateZapInOptions description
 * @returns Amount of LP Token you will receive
 */
declare function calculateZapIn(options: CalculateZapInOptions): bigint;
declare type Reserves = [bigint, bigint];
declare type Fraction = [bigint, bigint];
declare namespace DexV2Calculation {
    type InitialLiquidityOptions = {
        amountA: bigint;
        amountB: bigint;
    };
    type CalculateAmountOutOptions = {
        reserveIn: bigint;
        reserveOut: bigint;
        amountIn: bigint;
        tradingFeeNumerator: bigint;
    };
    type CalculateAmountOutFractionOptions = {
        reserveIn: bigint;
        reserveOut: bigint;
        amountIn: Fraction;
        tradingFeeNumerator: bigint;
    };
    type CalculateAmountInOptions = {
        reserveIn: bigint;
        reserveOut: bigint;
        amountOut: bigint;
        tradingFeeNumerator: bigint;
    };
    type CalculateMaxInSwapOptions = {
        reserveIn: bigint;
        reserveOut: bigint;
        tradingFeeNumerator: bigint;
        ioRatio: Fraction;
    };
    type CalculateDepositAmountOptions = {
        amountA: bigint;
        amountB: bigint;
        poolInfo: PoolV2.Info;
    };
    type CalculateDepositSwapAmountOptions = {
        amountIn: bigint;
        amountOut: bigint;
        reserveIn: bigint;
        reserveOut: bigint;
        tradingFeeNumerator: bigint;
    };
    type CalculateWithdrawAmountOptions = {
        datumReserves: Reserves;
        withdrawalLPAmount: bigint;
        totalLiquidity: bigint;
    };
    type CalculateZapOutAmountOptions = {
        withdrawalLPAmount: bigint;
        direction: OrderV2.Direction;
        poolInfo: PoolV2.Info;
    };
    function bigIntPow(x: bigint): bigint;
    function calculateInitialLiquidity({ amountA, amountB, }: InitialLiquidityOptions): bigint;
    function calculateAmountOut({ reserveIn, reserveOut, amountIn, tradingFeeNumerator, }: CalculateAmountOutOptions): bigint;
    function calculateAmountOutFraction({ reserveIn, reserveOut, amountIn, tradingFeeNumerator, }: CalculateAmountOutFractionOptions): [bigint, bigint];
    function calculateAmountIn({ reserveIn, reserveOut, amountOut, tradingFeeNumerator, }: CalculateAmountInOptions): bigint;
    function calculateMaxInSwap({ reserveIn, reserveOut, tradingFeeNumerator, ioRatio, }: CalculateMaxInSwapOptions): bigint;
    function calculateDepositAmount({ amountA, amountB, poolInfo, }: CalculateDepositAmountOptions): bigint;
    function calculateDepositSwapAmount({ amountIn, amountOut, reserveIn, reserveOut, tradingFeeNumerator, }: CalculateDepositSwapAmountOptions): Fraction;
    function calculateWithdrawAmount({ withdrawalLPAmount, datumReserves, totalLiquidity, }: CalculateWithdrawAmountOptions): {
        withdrawalA: bigint;
        withdrawalB: bigint;
    };
    function calculateZapOutAmount({ withdrawalLPAmount, direction, poolInfo, }: CalculateZapOutAmountOptions): bigint;
}

/**
 * Common options for build Minswap transaction
 * @sender The owner of this order, it will be used for cancelling this order
 * @availableUtxos Available UTxOs can be used in transaction
 */
declare type CommonOptions = {
    sender: Address;
    availableUtxos: UTxO[];
};
/**
 * Options for building cancel Order
 * @orderTxId Transaction ID which order is created
 * @sender The owner of this order. The @sender must be matched with data in Order's Datum
 */
declare type BuildCancelOrderOptions = {
    orderUtxo: UTxO;
    sender: Address;
};
/**
 * Options for building Deposit Order
 * @assetA @assetB Define pair which you want to deposit to
 * @amountA @amountB Define amount which you want to deposit to
 * @minimumLPReceived Minimum Received Amount you can accept after order is executed
 */
declare type BuildDepositTxOptions = CommonOptions & {
    assetA: Asset;
    assetB: Asset;
    amountA: bigint;
    amountB: bigint;
    minimumLPReceived: bigint;
};
/**
 * Options for building Zap In Order
 * @assetIn Asset you want to Zap
 * @assetOut The remaining asset of Pool which you want to Zap.
 *      For eg, in Pool ADA-MIN, if @assetIn is ADA then @assetOut will be MIN and vice versa
 * @minimumLPReceived Minimum Received Amount you can accept after order is executed
 */
declare type BuildZapInTxOptions = CommonOptions & {
    sender: Address;
    assetIn: Asset;
    amountIn: bigint;
    assetOut: Asset;
    minimumLPReceived: bigint;
};
/**
 * Options for building Withdrawal Order
 * @lpAsset LP Asset will be withdrawed
 * @lpAmount LP Asset amount will be withdrawed
 * @minimumAssetAReceived Minimum Received of Asset A in the Pool you can accept after order is executed
 * @minimumAssetBReceived Minimum Received of Asset A in the Pool you can accept after order is executed
 */
declare type BuildWithdrawTxOptions = CommonOptions & {
    sender: Address;
    lpAsset: Asset;
    lpAmount: bigint;
    minimumAssetAReceived: bigint;
    minimumAssetBReceived: bigint;
};
/**
 * Options for building Swap Exact Out Order
 * @assetIn Asset you want to Swap
 * @assetOut Asset you want to receive
 * @maximumAmountIn The maximum Amount of Asset In which will be spent after order is executed
 * @expectedAmountOut The expected Amount of Asset Out you want to receive after order is executed
 */
declare type BuildSwapExactOutTxOptions = CommonOptions & {
    sender: Address;
    assetIn: Asset;
    assetOut: Asset;
    maximumAmountIn: bigint;
    expectedAmountOut: bigint;
};
/**
 * Options for building Swap Exact In Order
 * @assetIn Asset and its amount you want to Swap
 * @amountIn Amount of Asset In you want to Swap
 * @assetOut Asset and you want to receive
 * @minimumAmountOut The minimum Amount of Asset Out you can accept after order is executed
 * @isLimitOrder Define this order is Limit Order or not
 */
declare type BuildSwapExactInTxOptions = CommonOptions & {
    sender: Address;
    assetIn: Asset;
    amountIn: bigint;
    assetOut: Asset;
    minimumAmountOut: bigint;
    isLimitOrder: boolean;
};
declare class Dex {
    private readonly lucid;
    private readonly networkId;
    private readonly networkEnv;
    private readonly dexVersion;
    constructor(lucid: Lucid);
    buildSwapExactInTx(options: BuildSwapExactInTxOptions): Promise<TxComplete>;
    buildSwapExactOutTx(options: BuildSwapExactOutTxOptions): Promise<TxComplete>;
    buildWithdrawTx(options: BuildWithdrawTxOptions): Promise<TxComplete>;
    buildZapInTx(options: BuildZapInTxOptions): Promise<TxComplete>;
    buildDepositTx(options: BuildDepositTxOptions): Promise<TxComplete>;
    buildCancelOrder(options: BuildCancelOrderOptions): Promise<TxComplete>;
}

/**
 * Options for building Pool V2 Creation transaction
 * @assetA
 * @assetB
 * @amountA
 * @amountB
 * @tradingFeeNumerator numerator of Pool's trading fee with denominator 10000
 *    Eg:
 *      - fee 0.05% -> tradingFeeNumerator 5
 *      - fee 0.3% -> tradingFeeNumerator 30
 *      - fee 1% -> tradingFeeNumerator 100
 */
declare type CreatePoolV2Options = {
    assetA: Asset;
    assetB: Asset;
    amountA: bigint;
    amountB: bigint;
    tradingFeeNumerator: bigint;
};
declare type BulkOrdersOption = {
    sender: Address;
    orderOptions: OrderOptions[];
    expiredOptions?: OrderV2.ExpirySetting;
    availableUtxos: UTxO[];
    composeTx?: Tx;
    authorizationMethodType?: OrderV2.AuthorizationMethodType;
};
declare type OrderV2SwapRouting = {
    lpAsset: Asset;
    direction: OrderV2.Direction;
};
declare type DepositOptions = {
    type: OrderV2.StepType.DEPOSIT;
    assetA: Asset;
    assetB: Asset;
    amountA: bigint;
    amountB: bigint;
    minimumLPReceived: bigint;
    killOnFailed: boolean;
};
declare type WithdrawOptions = {
    type: OrderV2.StepType.WITHDRAW;
    lpAmount: bigint;
    minimumAssetAReceived: bigint;
    minimumAssetBReceived: bigint;
    killOnFailed: boolean;
};
declare type SwapExactInOptions = {
    type: OrderV2.StepType.SWAP_EXACT_IN;
    assetIn: Asset;
    amountIn: bigint;
    minimumAmountOut: bigint;
    direction: OrderV2.Direction;
    killOnFailed: boolean;
    isLimitOrder: boolean;
};
declare type SwapExactOutOptions = {
    type: OrderV2.StepType.SWAP_EXACT_OUT;
    assetIn: Asset;
    maximumAmountIn: bigint;
    expectedReceived: bigint;
    direction: OrderV2.Direction;
    killOnFailed: boolean;
};
declare type StopOptions = {
    type: OrderV2.StepType.STOP;
    assetIn: Asset;
    amountIn: bigint;
    stopAmount: bigint;
    direction: OrderV2.Direction;
};
declare type OCOOptions = {
    type: OrderV2.StepType.OCO;
    assetIn: Asset;
    amountIn: bigint;
    limitAmount: bigint;
    stopAmount: bigint;
    direction: OrderV2.Direction;
};
declare type ZapOutOptions = {
    type: OrderV2.StepType.ZAP_OUT;
    lpAmount: bigint;
    direction: OrderV2.Direction;
    minimumReceived: bigint;
    killOnFailed: boolean;
};
declare type PartialSwapOptions = {
    type: OrderV2.StepType.PARTIAL_SWAP;
    assetIn: Asset;
    amountIn: bigint;
    direction: OrderV2.Direction;
    expectedInOutRatio: [bigint, bigint];
    maximumSwapTime: number;
    minimumSwapAmountRequired: bigint;
};
declare type WithdrawImbalanceOptions = {
    type: OrderV2.StepType.WITHDRAW_IMBALANCE;
    lpAmount: bigint;
    ratioAssetA: bigint;
    ratioAssetB: bigint;
    minimumAssetA: bigint;
    killOnFailed: boolean;
};
declare type MultiRoutingOptions = {
    type: OrderV2.StepType.SWAP_ROUTING;
    assetIn: Asset;
    amountIn: bigint;
    routings: OrderV2.Route[];
    minimumReceived: bigint;
};
declare type OrderOptions = (DepositOptions | WithdrawOptions | SwapExactInOptions | SwapExactOutOptions | StopOptions | OCOOptions | ZapOutOptions | PartialSwapOptions | WithdrawImbalanceOptions | MultiRoutingOptions) & {
    lpAsset: Asset;
};
declare type CancelBulkOrdersOptions = {
    orderOutRefs: OutRef[];
    composeTx?: Tx;
    AuthorizationMethodType?: OrderV2.AuthorizationMethodType;
};
declare class DexV2 {
    private readonly lucid;
    private readonly networkId;
    private readonly adapter;
    private readonly networkEnv;
    private readonly dexVersion;
    constructor(lucid: Lucid, adapter: BlockfrostAdapter);
    createPoolTx({ assetA, assetB, amountA, amountB, tradingFeeNumerator, }: CreatePoolV2Options): Promise<TxComplete>;
    private buildOrderValue;
    buildOrderStep(options: OrderOptions, finalBatcherFee: bigint): OrderV2.Step;
    private buildOrderAddress;
    private getOrderScriptHash;
    private getOrderMetadata;
    createBulkOrdersTx({ sender, orderOptions, expiredOptions, availableUtxos, composeTx, authorizationMethodType, }: BulkOrdersOption): Promise<TxComplete>;
    cancelOrder({ orderOutRefs, composeTx, }: CancelBulkOrdersOptions): Promise<TxComplete>;
}

export { ADA, Asset, BlockfrostAdapter, BlockfrostAdapterOptions, BuildCancelOrderOptions, BuildDepositTxOptions, BuildSwapExactInTxOptions, BuildSwapExactOutTxOptions, BuildWithdrawTxOptions, BuildZapInTxOptions, BulkOrdersOption, CalculateDepositOptions, CalculateSwapExactInOptions, CalculateSwapExactOutOptions, CalculateWithdrawOptions, CalculateZapInOptions, CancelBulkOrdersOptions, CreatePoolV2Options, DEFAULT_POOL_V2_TRADING_FEE_DENOMINATOR, DepositOptions, Dex, DexV1Constant, DexV2, DexV2Calculation, DexV2Constant, FIXED_DEPOSIT_ADA, GetPoolByIdParams, GetPoolHistoryParams, GetPoolInTxParams, GetPoolPriceParams, GetPoolsParams, GetStablePoolInTxParams, GetV2PoolPriceParams, MetadataMessage, MultiRoutingOptions, NetworkEnvironment, NetworkId, OCOOptions, OrderOptions, OrderV1, OrderV2, OrderV2SwapRouting, PartialSwapOptions, PoolV1, PoolV2, StableOrder, StablePool, StableswapConstant, StopOptions, SwapExactInOptions, SwapExactOutOptions, WithdrawImbalanceOptions, WithdrawOptions, ZapOutOptions, calculateDeposit, calculateSwapExactIn, calculateSwapExactOut, calculateWithdraw, calculateZapIn };
