import { BlockfrostServerError } from '@blockfrost/blockfrost-js';
import invariant from '@minswap/tiny-invariant';
import Big from 'big.js';
import { Constr, Data, C, getAddressDetails } from 'lucid-cardano';
import { SHA3 } from 'sha3';
import BigNumber from 'bignumber.js';

var StringUtils;
((StringUtils2) => {
  function compare(s1, s2) {
    if (s1 < s2) {
      return -1;
    }
    if (s1 === s2) {
      return 0;
    }
    return 1;
  }
  StringUtils2.compare = compare;
})(StringUtils || (StringUtils = {}));

const ADA = {
  policyId: "",
  tokenName: ""
};
var Asset;
((Asset2) => {
  function fromString(s) {
    if (s === "lovelace") {
      return {
        policyId: "",
        tokenName: ""
      };
    }
    const policyId = s.slice(0, 56);
    const tokenName = s.slice(56);
    return {
      policyId,
      tokenName
    };
  }
  Asset2.fromString = fromString;
  function toString(asset) {
    const { policyId, tokenName } = asset;
    if (policyId === "" && tokenName === "") {
      return "lovelace";
    }
    return policyId + tokenName;
  }
  Asset2.toString = toString;
  function toPlutusData(asset) {
    const { policyId, tokenName } = asset;
    return new Constr(0, [
      policyId,
      tokenName
    ]);
  }
  Asset2.toPlutusData = toPlutusData;
  function fromPlutusData(data) {
    if (data.index !== 0) {
      throw new Error(`Index of Asset must be 0, actual: ${data.index}`);
    }
    return {
      policyId: data.fields[0],
      tokenName: data.fields[1]
    };
  }
  Asset2.fromPlutusData = fromPlutusData;
  function compare(a1, a2) {
    if (a1.policyId === a2.policyId) {
      return StringUtils.compare(a1.tokenName, a2.tokenName);
    }
    return StringUtils.compare(a1.policyId, a2.policyId);
  }
  Asset2.compare = compare;
  function equals(a1, a2) {
    return a1.policyId === a2.policyId && a1.tokenName === a2.tokenName;
  }
  Asset2.equals = equals;
})(Asset || (Asset = {}));

var NetworkId = /* @__PURE__ */ ((NetworkId2) => {
  NetworkId2[NetworkId2["TESTNET"] = 0] = "TESTNET";
  NetworkId2[NetworkId2["MAINNET"] = 1] = "MAINNET";
  return NetworkId2;
})(NetworkId || {});
var NetworkEnvironment = /* @__PURE__ */ ((NetworkEnvironment2) => {
  NetworkEnvironment2[NetworkEnvironment2["MAINNET"] = 764824073] = "MAINNET";
  NetworkEnvironment2[NetworkEnvironment2["TESTNET_PREVIEW"] = 2] = "TESTNET_PREVIEW";
  NetworkEnvironment2[NetworkEnvironment2["TESTNET_PREPROD"] = 1] = "TESTNET_PREPROD";
  return NetworkEnvironment2;
})(NetworkEnvironment || {});

var DexV1Constant;
((DexV1Constant2) => {
  DexV1Constant2.ORDER_BASE_ADDRESS = {
    [NetworkId.TESTNET]: "addr_test1zzn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uwurajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upq932hcy",
    [NetworkId.MAINNET]: "addr1zxn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uw6j2c79gy9l76sdg0xwhd7r0c0kna0tycz4y5s6mlenh8pq6s3z70"
  };
  DexV1Constant2.POOL_SCRIPT_HASH = "script1uychk9f04tqngfhx4qlqdlug5ntzen3uzc62kzj7cyesjk0d9me";
  DexV1Constant2.FACTORY_POLICY_ID = "13aa2accf2e1561723aa26871e071fdf32c867cff7e7d50ad470d62f";
  DexV1Constant2.FACTORY_ASSET_NAME = "4d494e53574150";
  DexV1Constant2.LP_POLICY_ID = "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86";
  DexV1Constant2.POOL_NFT_POLICY_ID = "0be55d262b29f564998ff81efe21bdc0022621c12f15af08d0f2ddb1";
  DexV1Constant2.ORDER_SCRIPT = {
    type: "PlutusV1",
    script: "59014f59014c01000032323232323232322223232325333009300e30070021323233533300b3370e9000180480109118011bae30100031225001232533300d3300e22533301300114a02a66601e66ebcc04800400c5288980118070009bac3010300c300c300c300c300c300c300c007149858dd48008b18060009baa300c300b3754601860166ea80184ccccc0288894ccc04000440084c8c94ccc038cd4ccc038c04cc030008488c008dd718098018912800919b8f0014891ce1317b152faac13426e6a83e06ff88a4d62cce3c1634ab0a5ec133090014a0266008444a00226600a446004602600a601a00626600a008601a006601e0026ea8c03cc038dd5180798071baa300f300b300e3754601e00244a0026eb0c03000c92616300a001375400660106ea8c024c020dd5000aab9d5744ae688c8c0088cc0080080048c0088cc00800800555cf2ba15573e6e1d200201"
  };
})(DexV1Constant || (DexV1Constant = {}));
var StableswapConstant;
((StableswapConstant2) => {
  StableswapConstant2.CONFIG = {
    [NetworkId.TESTNET]: [
      {
        orderAddress: "addr_test1zq8spknltt6yyz2505rhc5lqw89afc4anhu4u0347n5dz8urajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqa63kst",
        poolAddress: "addr_test1zr3hs60rn9x49ahuduuzmnlhnema0jsl4d3ujrf3cmurhmvrajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqcgz9yc",
        nftAsset: "06fe1ba957728130154154d5e5b25a7b533ebe6c4516356c0aa69355646a65642d697573642d76312e342d6c70",
        lpAsset: "d16339238c9e1fb4d034b6a48facb2f97794a9cdb7bc049dd7c49f54646a65642d697573642d76312e342d6c70",
        assets: [
          "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed7274444a4544",
          "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed727469555344"
        ],
        multiples: [1n, 1n],
        fee: 1000000n,
        adminFee: 5000000000n,
        feeDenominator: 10000000000n
      },
      {
        orderAddress: "addr_test1zp3mf7r63u8km2d69kh6v2axlvl04yunmmj67vprljuht4urajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqhelj6n",
        poolAddress: "addr_test1zzc8ar93kgntz3lv95uauhe29kj4yj84mxhg5v9dqj4k7p5rajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqujv25l",
        nftAsset: "06fe1ba957728130154154d5e5b25a7b533ebe6c4516356c0aa69355757364632d757364742d76312e342d6c70",
        lpAsset: "8db03e0cc042a5f82434123a0509f590210996f1c7410c94f913ac48757364632d757364742d76312e342d6c70",
        assets: [
          "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed727455534443",
          "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed727455534454"
        ],
        multiples: [1n, 1n],
        fee: 1000000n,
        adminFee: 5000000000n,
        feeDenominator: 10000000000n
      },
      {
        orderAddress: "addr_test1zqpmw0kkgm6fp9x0asq5vwuaccweeqdv3edhwckqr2gnvzurajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upq9z8vxj",
        poolAddress: "addr_test1zqh2uv0wvrtt579e92q35ktkzcj3lj3nzdm3xjpsdack3q5rajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqud27a8",
        nftAsset: "06fe1ba957728130154154d5e5b25a7b533ebe6c4516356c0aa69355646a65642d697573642d6461692d76312e342d6c70",
        lpAsset: "492fd7252d5914c9f5acb7eeb6b905b3a65b9a952c2300de34eb86c5646a65642d697573642d6461692d76312e342d6c70",
        assets: [
          "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed7274444a4544",
          "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed727469555344",
          "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed7274444149"
        ],
        multiples: [1n, 1n, 1n],
        fee: 1000000n,
        adminFee: 5000000000n,
        feeDenominator: 10000000000n
      }
    ],
    [NetworkId.MAINNET]: [
      {
        orderAddress: "addr1w9xy6edqv9hkptwzewns75ehq53nk8t73je7np5vmj3emps698n9g",
        poolAddress: "addr1wy7kkcpuf39tusnnyga5t2zcul65dwx9yqzg7sep3cjscesx2q5m5",
        nftAsset: "5d4b6afd3344adcf37ccef5558bb87f522874578c32f17160512e398444a45442d695553442d534c50",
        lpAsset: "2c07095028169d7ab4376611abef750623c8f955597a38cd15248640444a45442d695553442d534c50",
        assets: [
          "8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344",
          "f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069555344"
        ],
        multiples: [1n, 1n],
        fee: 1000000n,
        adminFee: 5000000000n,
        feeDenominator: 10000000000n
      },
      {
        orderAddress: "addr1w93d8cuht3hvqt2qqfjqgyek3gk5d6ss2j93e5sh505m0ng8cmze2",
        poolAddress: "addr1wx8d45xlfrlxd7tctve8xgdtk59j849n00zz2pgyvv47t8sxa6t53",
        nftAsset: "d97fa91daaf63559a253970365fb219dc4364c028e5fe0606cdbfff9555344432d444a45442d534c50",
        lpAsset: "ac49e0969d76ed5aa9e9861a77be65f4fc29e9a979dc4c37a99eb8f4555344432d444a45442d534c50",
        assets: [
          "25c5de5f5b286073c593edfd77b48abc7a48e5a4f3d4cd9d428ff93555534443",
          "8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344"
        ],
        multiples: [1n, 100n],
        fee: 1000000n,
        adminFee: 5000000000n,
        feeDenominator: 10000000000n
      },
      {
        orderAddress: "addr1wxtv9k2lcum5pmcc4wu44a5tufulszahz84knff87wcawycez9lug",
        poolAddress: "addr1w9520fyp6g3pjwd0ymfy4v2xka54ek6ulv4h8vce54zfyfcm2m0sm",
        nftAsset: "96402c6f5e7a04f16b4d6f500ab039ff5eac5d0226d4f88bf5523ce85553444d2d695553442d534c50",
        lpAsset: "31f92531ac9f1af3079701fab7c66ce997eb07988277ee5b9d6403015553444d2d695553442d534c50",
        assets: [
          "c48cbb3d5e57ed56e276bc45f99ab39abe94e6cd7ac39fb402da47ad0014df105553444d",
          "f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069555344"
        ],
        multiples: [1n, 1n],
        fee: 1000000n,
        adminFee: 5000000000n,
        feeDenominator: 10000000000n
      },
      {
        orderAddress: "addr1wxr9ppdymqgw6g0hvaaa7wc6j0smwh730ujx6lczgdynehsguav8d",
        poolAddress: "addr1wxxdvtj6y4fut4tmu796qpvy2xujtd836yg69ahat3e6jjcelrf94",
        nftAsset: "07b0869ed7488657e24ac9b27b3f0fb4f76757f444197b2a38a15c3c444a45442d5553444d2d534c50",
        lpAsset: "5b042cf53c0b2ce4f30a9e743b4871ad8c6dcdf1d845133395f55a8e444a45442d5553444d2d534c50",
        assets: [
          "8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344",
          "c48cbb3d5e57ed56e276bc45f99ab39abe94e6cd7ac39fb402da47ad0014df105553444d"
        ],
        multiples: [1n, 1n],
        fee: 1000000n,
        adminFee: 5000000000n,
        feeDenominator: 10000000000n
      }
    ]
  };
  StableswapConstant2.DEPLOYED_SCRIPTS = {
    [NetworkId.TESTNET]: {
      "06fe1ba957728130154154d5e5b25a7b533ebe6c4516356c0aa69355646a65642d697573642d76312e342d6c70": {
        order: {
          txHash: "527e421bc3eb8b9e5ec0a9ad214bb9b76148f57b9a5a8cbd83a51264f943e91d",
          outputIndex: 0
        },
        pool: {
          txHash: "527e421bc3eb8b9e5ec0a9ad214bb9b76148f57b9a5a8cbd83a51264f943e91d",
          outputIndex: 1
        },
        lp: {
          txHash: "527e421bc3eb8b9e5ec0a9ad214bb9b76148f57b9a5a8cbd83a51264f943e91d",
          outputIndex: 2
        },
        poolBatching: {
          txHash: "527e421bc3eb8b9e5ec0a9ad214bb9b76148f57b9a5a8cbd83a51264f943e91d",
          outputIndex: 3
        }
      },
      "06fe1ba957728130154154d5e5b25a7b533ebe6c4516356c0aa69355757364632d757364742d76312e342d6c70": {
        order: {
          txHash: "cf699550642c8ffc1673d1e5d56d8562ca7c7f5c0b513a8428c3f52cdcc8fdb7",
          outputIndex: 0
        },
        pool: {
          txHash: "cf699550642c8ffc1673d1e5d56d8562ca7c7f5c0b513a8428c3f52cdcc8fdb7",
          outputIndex: 1
        },
        lp: {
          txHash: "cf699550642c8ffc1673d1e5d56d8562ca7c7f5c0b513a8428c3f52cdcc8fdb7",
          outputIndex: 2
        },
        poolBatching: {
          txHash: "cf699550642c8ffc1673d1e5d56d8562ca7c7f5c0b513a8428c3f52cdcc8fdb7",
          outputIndex: 3
        }
      },
      "06fe1ba957728130154154d5e5b25a7b533ebe6c4516356c0aa69355646a65642d697573642d6461692d76312e342d6c70": {
        order: {
          txHash: "a8ab602259654697c85e2f61752d34cdb631f314eaeded0676fee6f6be70afe7",
          outputIndex: 0
        },
        pool: {
          txHash: "a8ab602259654697c85e2f61752d34cdb631f314eaeded0676fee6f6be70afe7",
          outputIndex: 1
        },
        lp: {
          txHash: "a8ab602259654697c85e2f61752d34cdb631f314eaeded0676fee6f6be70afe7",
          outputIndex: 2
        },
        poolBatching: {
          txHash: "a8ab602259654697c85e2f61752d34cdb631f314eaeded0676fee6f6be70afe7",
          outputIndex: 3
        }
      }
    },
    [NetworkId.MAINNET]: {
      "5d4b6afd3344adcf37ccef5558bb87f522874578c32f17160512e398444a45442d695553442d534c50": {
        order: {
          txHash: "20227174ec2f7853a71a02c435d063b3bf63851d4e0ad9a0c09250a087a6577e",
          outputIndex: 0
        },
        pool: {
          txHash: "20227174ec2f7853a71a02c435d063b3bf63851d4e0ad9a0c09250a087a6577e",
          outputIndex: 1
        },
        lp: {
          txHash: "20227174ec2f7853a71a02c435d063b3bf63851d4e0ad9a0c09250a087a6577e",
          outputIndex: 2
        },
        poolBatching: {
          txHash: "20227174ec2f7853a71a02c435d063b3bf63851d4e0ad9a0c09250a087a6577e",
          outputIndex: 3
        }
      },
      d97fa91daaf63559a253970365fb219dc4364c028e5fe0606cdbfff9555344432d444a45442d534c50: {
        order: {
          txHash: "8b880e77a726e76e5dd585cda2c4c2ac93f1cfccc06910f00550fb820ae1fc54",
          outputIndex: 0
        },
        pool: {
          txHash: "8b880e77a726e76e5dd585cda2c4c2ac93f1cfccc06910f00550fb820ae1fc54",
          outputIndex: 1
        },
        lp: {
          txHash: "8b880e77a726e76e5dd585cda2c4c2ac93f1cfccc06910f00550fb820ae1fc54",
          outputIndex: 2
        },
        poolBatching: {
          txHash: "8b880e77a726e76e5dd585cda2c4c2ac93f1cfccc06910f00550fb820ae1fc54",
          outputIndex: 3
        }
      },
      "96402c6f5e7a04f16b4d6f500ab039ff5eac5d0226d4f88bf5523ce85553444d2d695553442d534c50": {
        order: {
          txHash: "48019a931af442e1eedab6c5b52b3069cf6eadb2483a2131f517e62fddfd5662",
          outputIndex: 0
        },
        pool: {
          txHash: "48019a931af442e1eedab6c5b52b3069cf6eadb2483a2131f517e62fddfd5662",
          outputIndex: 1
        },
        lp: {
          txHash: "48019a931af442e1eedab6c5b52b3069cf6eadb2483a2131f517e62fddfd5662",
          outputIndex: 2
        },
        poolBatching: {
          txHash: "48019a931af442e1eedab6c5b52b3069cf6eadb2483a2131f517e62fddfd5662",
          outputIndex: 3
        }
      },
      "07b0869ed7488657e24ac9b27b3f0fb4f76757f444197b2a38a15c3c444a45442d5553444d2d534c50": {
        order: {
          txHash: "dddccee9cd58cbf712f2ff2c49ea20537db681a333c701106aa13cd57aee3873",
          outputIndex: 0
        },
        pool: {
          txHash: "dddccee9cd58cbf712f2ff2c49ea20537db681a333c701106aa13cd57aee3873",
          outputIndex: 1
        },
        lp: {
          txHash: "dddccee9cd58cbf712f2ff2c49ea20537db681a333c701106aa13cd57aee3873",
          outputIndex: 2
        },
        poolBatching: {
          txHash: "dddccee9cd58cbf712f2ff2c49ea20537db681a333c701106aa13cd57aee3873",
          outputIndex: 3
        }
      }
    }
  };
})(StableswapConstant || (StableswapConstant = {}));
var DexV2Constant;
((DexV2Constant2) => {
  DexV2Constant2.CONFIG = {
    [NetworkId.TESTNET]: {
      factoryAsset: "d6aae2059baee188f74917493cf7637e679cd219bdfbbf4dcbeb1d0b4d5346",
      poolAuthenAsset: "d6aae2059baee188f74917493cf7637e679cd219bdfbbf4dcbeb1d0b4d5350",
      globalSettingAsset: "d6aae2059baee188f74917493cf7637e679cd219bdfbbf4dcbeb1d0b4d534753",
      lpPolicyId: "d6aae2059baee188f74917493cf7637e679cd219bdfbbf4dcbeb1d0b",
      globalSettingScriptHash: "d6aae2059baee188f74917493cf7637e679cd219bdfbbf4dcbeb1d0b",
      globalSettingScriptHashBech32: "script1664wypvm4msc3a6fzayneamr0enee5sehham7nwtavwsk2s2vg9",
      orderScriptHash: "da9525463841173ad1230b1d5a1b5d0a3116bbdeb4412327148a1b7a",
      poolScriptHash: "d6ba9b7509eac866288ff5072d2a18205ac56f744bc82dcd808cb8fe",
      poolScriptHashBech32: "script166afkagfatyxv2y075rj62scypdv2mm5f0yzmnvq3ju0uqqmszv",
      poolCreationAddress: "addr_test1zrtt4xm4p84vse3g3l6swtf2rqs943t0w39ustwdszxt3l5rajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqhns793",
      factoryScriptHash: "6e23fe172b5b50e2ad59aded9ee8d488f74c7f4686f91b032220adad",
      factoryScriptHashBech32: "script1dc3lu9ettdgw9t2e4hkea6x53rm5cl6xsmu3kqezyzk66vpljxc",
      factoryAddress: "addr_test1zphz8lsh9dd4pc4dtxk7m8hg6jy0wnrlg6r0jxcrygs2mtvrajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqjgg24z",
      expiredOrderCancelAddress: "stake_test17rytpnrpxax5p8leepgjx9cq8ecedgly6jz4xwvvv4kvzfqz6sgpf",
      poolBatchingAddress: "stake_test17rann6nth9675m0y5tz32u3rfhzcfjymanxqnfyexsufu5glcajhf",
      orderEnterpriseAddress: "addr_test1wrdf2f2x8pq3wwk3yv936ksmt59rz94mm66yzge8zj9pk7s0kjph3"
    },
    [NetworkId.MAINNET]: {
      factoryAsset: "f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c4d5346",
      poolAuthenAsset: "f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c4d5350",
      globalSettingAsset: "f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c4d534753",
      lpPolicyId: "f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c",
      globalSettingScriptHash: "f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c",
      globalSettingScriptHashBech32: "script17kqgctyepkrd549le97cnnhxa73qekzxzctrt9rcm945c880puk",
      orderScriptHash: "c3e28c36c3447315ba5a56f33da6a6ddc1770a876a8d9f0cb3a97c4c",
      poolScriptHash: "ea07b733d932129c378af627436e7cbc2ef0bf96e0036bb51b3bde6b",
      poolScriptHashBech32: "script1agrmwv7exgffcdu27cn5xmnuhsh0p0ukuqpkhdgm800xksw7e2w",
      poolCreationAddress: "addr1z84q0denmyep98ph3tmzwsmw0j7zau9ljmsqx6a4rvaau66j2c79gy9l76sdg0xwhd7r0c0kna0tycz4y5s6mlenh8pq777e2a",
      factoryScriptHash: "7bc5fbd41a95f561be84369631e0e35895efb0b73e0a7480bb9ed730",
      factoryScriptHashBech32: "script100zlh4q6jh6kr05yx6trrc8rtz27lv9h8c98fq9mnmtnqfa47eg",
      factoryAddress: "addr1z9aut775r22l2cd7ssmfvv0qudvftmaskulq5ayqhw0dwvzj2c79gy9l76sdg0xwhd7r0c0kna0tycz4y5s6mlenh8pqgjw6pl",
      expiredOrderCancelAddress: "stake178ytpnrpxax5p8leepgjx9cq8ecedgly6jz4xwvvv4kvzfq9s6295",
      poolBatchingAddress: "stake17y02a946720zw6pw50upt2arvxsvvpvaghjtl054h0f0gjsfyjz59",
      orderEnterpriseAddress: "addr1w8p79rpkcdz8x9d6tft0x0dx5mwuzac2sa4gm8cvkw5hcnqst2ctf"
    }
  };
  DexV2Constant2.DEPLOYED_SCRIPTS = {
    [NetworkId.TESTNET]: {
      order: {
        txHash: "8c98f0530cba144d264fbd2731488af25257d7ce6a0cd1586fc7209363724f03",
        outputIndex: 0
      },
      pool: {
        txHash: "9f30b1c3948a009ceebda32d0b1d25699674b2eaf8b91ef029a43bfc1073ce28",
        outputIndex: 0
      },
      factory: {
        txHash: "9741d59656e9ad54f197b0763482eede9a6fa1616c4547797eee6617f92a1396",
        outputIndex: 0
      },
      authen: {
        txHash: "c429b8ee27e5761ba8714e26e3a5899886cd28d136d43e969d4bc1acf0f72d4a",
        outputIndex: 0
      },
      poolBatching: {
        txHash: "b0a6c5512735c7a183a167eed035ac75c191d6ff5be9736dfa1f1f02f7ae5dbc",
        outputIndex: 0
      },
      expiredOrderCancellation: {
        txHash: "ee718dd86e3cb89e802aa8b2be252fccf6f15263f4a26b5f478c5135c40264c6",
        outputIndex: 0
      }
    },
    [NetworkId.MAINNET]: {
      order: {
        txHash: "cf4ecddde0d81f9ce8fcc881a85eb1f8ccdaf6807f03fea4cd02da896a621776",
        outputIndex: 0
      },
      pool: {
        txHash: "2536194d2a976370a932174c10975493ab58fd7c16395d50e62b7c0e1949baea",
        outputIndex: 0
      },
      factory: {
        txHash: "59c7fa5c30cbab4e6d38f65e15d1adef71495321365588506ad089d237b602e0",
        outputIndex: 0
      },
      authen: {
        txHash: "dbc1498500a6e79baa0f34d10de55cdb4289ca6c722bd70e1e1b78a858f136b9",
        outputIndex: 0
      },
      poolBatching: {
        txHash: "d46bd227bd2cf93dedd22ae9b6d92d30140cf0d68b756f6608e38d680c61ad17",
        outputIndex: 0
      },
      expiredOrderCancellation: {
        txHash: "ef3acc7dfc5a98bffe8f4d4400e65a9ade5a1316b2fcb7145c3b83dba38a66f5",
        outputIndex: 0
      }
    }
  };
})(DexV2Constant || (DexV2Constant = {}));
var MetadataMessage = /* @__PURE__ */ ((MetadataMessage2) => {
  MetadataMessage2["DEPOSIT_ORDER"] = "SDK Minswap: Deposit Order";
  MetadataMessage2["CANCEL_ORDER"] = "SDK Minswap: Cancel Order";
  MetadataMessage2["ZAP_IN_ORDER"] = "SDK Minswap: Zap Order";
  MetadataMessage2["ZAP_OUT_ORDER"] = "SDK Minswap: Zap Out Order";
  MetadataMessage2["SWAP_EXACT_IN_ORDER"] = "SDK Minswap: Swap Exact In Order";
  MetadataMessage2["SWAP_EXACT_IN_LIMIT_ORDER"] = "SDK Minswap: Swap Exact In Limit Order";
  MetadataMessage2["SWAP_EXACT_OUT_ORDER"] = "SDK Minswap: Swap Exact Out Order";
  MetadataMessage2["WITHDRAW_ORDER"] = "SDK Minswap: Withdraw Order";
  MetadataMessage2["STOP_ORDER"] = "SDK Minswap: Stop Order";
  MetadataMessage2["OCO_ORDER"] = "SDK Minswap: OCO Order";
  MetadataMessage2["ROUTING_ORDER"] = "SDK Minswap: Routing Order";
  MetadataMessage2["PARTIAL_SWAP_ORDER"] = "SDK Minswap: Partial Fill Order";
  MetadataMessage2["DONATION_ORDER"] = "Minswap: Donation Order";
  MetadataMessage2["MIXED_ORDERS"] = "SDK Minswap: Mixed Orders";
  MetadataMessage2["CREATE_POOL"] = "SDK Minswap: Create Pool";
  return MetadataMessage2;
})(MetadataMessage || {});
const FIXED_DEPOSIT_ADA = 2000000n;

var FactoryV2;
((FactoryV22) => {
  let Datum;
  ((Datum2) => {
    function toPlutusData(datum) {
      return new Constr(0, [
        datum.head,
        datum.tail
      ]);
    }
    Datum2.toPlutusData = toPlutusData;
    function fromPlutusData(data) {
      if (data.index !== 0) {
        throw new Error(`Index of Factory V2 Datum must be 0, actual: ${data.index}`);
      }
      return {
        head: data.fields[0],
        tail: data.fields[1]
      };
    }
    Datum2.fromPlutusData = fromPlutusData;
  })(Datum = FactoryV22.Datum || (FactoryV22.Datum = {}));
  ((Redeemer2) => {
    function toPlutusData(redeemer) {
      return new Constr(0, [
        Asset.toPlutusData(redeemer.assetA),
        Asset.toPlutusData(redeemer.assetB)
      ]);
    }
    Redeemer2.toPlutusData = toPlutusData;
    function fromPlutusData(data) {
      if (data.index !== 0) {
        throw new Error(`Index of Factory V2 Datum must be 0, actual: ${data.index}`);
      }
      return {
        assetA: Asset.fromPlutusData(data.fields[0]),
        assetB: Asset.fromPlutusData(data.fields[1])
      };
    }
    Redeemer2.fromPlutusData = fromPlutusData;
  })(FactoryV22.Redeemer || (FactoryV22.Redeemer = {}));
  class State {
    address;
    txIn;
    value;
    datumCbor;
    datum;
    constructor(networkId, address, txIn, value, datum) {
      this.address = address;
      this.txIn = txIn;
      this.value = value;
      this.datumCbor = datum;
      this.datum = Datum.fromPlutusData(Data.from(datum));
      const config = DexV2Constant.CONFIG[networkId];
      if (!value.find((v) => v.unit === config.factoryAsset && v.quantity === "1")) {
        throw new Error("Cannot find the Factory Authentication Asset in the value");
      }
    }
    get head() {
      return this.datum.head;
    }
    get tail() {
      return this.datum.tail;
    }
  }
  FactoryV22.State = State;
})(FactoryV2 || (FactoryV2 = {}));

function sha3(hex) {
  const hash = new SHA3(256);
  hash.update(hex, "hex");
  return hash.digest("hex");
}

var LucidCredential;
((LucidCredential2) => {
  function toPlutusData(data) {
    const constructor = data.type === "Key" ? 0 : 1;
    return new Constr(constructor, [data.hash]);
  }
  LucidCredential2.toPlutusData = toPlutusData;
  function fromPlutusData(data) {
    switch (data.index) {
      case 0: {
        return {
          type: "Key",
          hash: data.fields[0]
        };
      }
      case 1: {
        return {
          type: "Script",
          hash: data.fields[0]
        };
      }
      default: {
        throw new Error(`Index of Credentail must be 0 or 1, actual: ${data.index}`);
      }
    }
  }
  LucidCredential2.fromPlutusData = fromPlutusData;
  function toCSLStakeCredential(credential) {
    switch (credential.type) {
      case "Key": {
        return C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_hex(credential.hash));
      }
      case "Script": {
        return C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(credential.hash));
      }
    }
  }
  LucidCredential2.toCSLStakeCredential = toCSLStakeCredential;
})(LucidCredential || (LucidCredential = {}));
var AddressPlutusData;
((AddressPlutusData2) => {
  function toPlutusData(address) {
    const addressDetails = getAddressDetails(address);
    if (addressDetails.type === "Base") {
      invariant(addressDetails.paymentCredential && addressDetails.stakeCredential, "baseAddress must have both paymentCredential and stakeCredential");
      return new Constr(0, [
        LucidCredential.toPlutusData(addressDetails.paymentCredential),
        new Constr(0, [
          new Constr(0, [
            LucidCredential.toPlutusData(addressDetails.stakeCredential)
          ])
        ])
      ]);
    }
    if (addressDetails.type === "Enterprise") {
      invariant(addressDetails.paymentCredential, "EnterpriseAddress must has paymentCredential");
      return new Constr(0, [
        LucidCredential.toPlutusData(addressDetails.paymentCredential),
        new Constr(1, [])
      ]);
    }
    throw new Error("only supports base address, enterprise address");
  }
  AddressPlutusData2.toPlutusData = toPlutusData;
  function fromPlutusData(networkId, data) {
    switch (data.index) {
      case 0: {
        const paymentCredential = LucidCredential.fromPlutusData(data.fields[0]);
        const cslPaymentCredential = LucidCredential.toCSLStakeCredential(paymentCredential);
        const maybeStakeCredentialConstr = data.fields[1];
        switch (maybeStakeCredentialConstr.index) {
          case 0: {
            const stakeCredentialConstr = maybeStakeCredentialConstr.fields[0];
            switch (stakeCredentialConstr.index) {
              case 0: {
                const stakeCredential = LucidCredential.fromPlutusData(stakeCredentialConstr.fields[0]);
                const cslStakeCredential = LucidCredential.toCSLStakeCredential(stakeCredential);
                const cslAddress = C.BaseAddress.new(networkId, cslPaymentCredential, cslStakeCredential).to_address();
                return cslAddress.to_bech32(void 0);
              }
              case 1: {
                throw new Error(`Pointer Address has not been supported yet`);
              }
              default: {
                throw new Error(`Index of StakeCredentail must be 0 or 1, actual: ${stakeCredentialConstr.index}`);
              }
            }
          }
          case 1: {
            const cslAddress = C.EnterpriseAddress.new(networkId, cslPaymentCredential).to_address();
            return cslAddress.to_bech32(void 0);
          }
          default: {
            throw new Error(`Index of Maybe Stake Credentail must be 0 or 1, actual: ${maybeStakeCredentialConstr.index}`);
          }
        }
      }
      default: {
        throw new Error(`Index of Address must be 0, actual: ${data.index}`);
      }
    }
  }
  AddressPlutusData2.fromPlutusData = fromPlutusData;
})(AddressPlutusData || (AddressPlutusData = {}));

function getScriptHashFromAddress(addr) {
  const cslAddr = C.Address.from_bech32(addr);
  const specificAddr = C.BaseAddress.from_address(cslAddr) || C.EnterpriseAddress.from_address(cslAddr) || C.PointerAddress.from_address(cslAddr) || C.RewardAddress.from_address(cslAddr);
  if (!specificAddr) {
    return null;
  }
  return specificAddr.payment_cred().to_scripthash()?.to_bech32("script") ?? null;
}

function normalizeAssets(a, b) {
  if (a === "lovelace") {
    return [a, b];
  }
  if (b === "lovelace") {
    return [b, a];
  }
  if (a < b) {
    return [a, b];
  } else {
    return [b, a];
  }
}
var PoolFeeSharing;
((PoolFeeSharing2) => {
  function toPlutusData(feeSharing) {
    const { feeTo, feeToDatumHash } = feeSharing;
    return new Constr(0, [
      AddressPlutusData.toPlutusData(feeTo),
      feeToDatumHash ? new Constr(0, [feeToDatumHash]) : new Constr(1, [])
    ]);
  }
  PoolFeeSharing2.toPlutusData = toPlutusData;
  function fromPlutusData(networkId, data) {
    if (data.index !== 0) {
      throw new Error(`Index of Pool Profit Sharing must be 0, actual: ${data.index}`);
    }
    let feeToDatumHash = void 0;
    const maybeFeeToDatumHash = data.fields[1];
    switch (maybeFeeToDatumHash.index) {
      case 0: {
        feeToDatumHash = maybeFeeToDatumHash.fields[0];
        break;
      }
      case 1: {
        feeToDatumHash = void 0;
        break;
      }
      default: {
        throw new Error(`Index of Fee To DatumHash must be 0 or 1, actual: ${maybeFeeToDatumHash.index}`);
      }
    }
    return {
      feeTo: AddressPlutusData.fromPlutusData(networkId, data.fields[0]),
      feeToDatumHash
    };
  }
  PoolFeeSharing2.fromPlutusData = fromPlutusData;
})(PoolFeeSharing || (PoolFeeSharing = {}));
function checkValidPoolOutput(poolAddress, value, datumHash) {
  invariant(getScriptHashFromAddress(poolAddress) === DexV1Constant.POOL_SCRIPT_HASH, `invalid pool address: ${poolAddress}`);
  if (value.find(({ unit }) => unit === `${DexV1Constant.FACTORY_POLICY_ID}${DexV1Constant.FACTORY_ASSET_NAME}`)?.quantity !== "1") {
    throw new Error(`expect pool to have 1 factory token`);
  }
  invariant(datumHash, `expect pool to have datum hash, got ${datumHash}`);
}
function isValidPoolOutput(poolAddress, value, datumHash) {
  try {
    checkValidPoolOutput(poolAddress, value, datumHash);
    return true;
  } catch (err) {
    return false;
  }
}

const DEFAULT_POOL_V2_TRADING_FEE_DENOMINATOR = 10000n;
var PoolV1;
((PoolV12) => {
  class State {
    address;
    txIn;
    value;
    datumHash;
    assetA;
    assetB;
    constructor(address, txIn, value, datumHash) {
      this.address = address;
      this.txIn = txIn;
      this.value = value;
      this.datumHash = datumHash;
      const nft = value.find(({ unit }) => unit.startsWith(DexV1Constant.POOL_NFT_POLICY_ID));
      invariant(nft, "pool doesn't have NFT");
      const poolId = nft.unit.slice(56);
      const relevantAssets = value.filter(({ unit }) => !unit.startsWith(DexV1Constant.FACTORY_POLICY_ID) && !unit.endsWith(poolId));
      switch (relevantAssets.length) {
        case 2: {
          this.assetA = "lovelace";
          const nonADAAssets = relevantAssets.filter(({ unit }) => unit !== "lovelace");
          invariant(nonADAAssets.length === 1, "pool must have 1 non-ADA asset");
          this.assetB = nonADAAssets[0].unit;
          break;
        }
        case 3: {
          const nonADAAssets = relevantAssets.filter(({ unit }) => unit !== "lovelace");
          invariant(nonADAAssets.length === 2, "pool must have 1 non-ADA asset");
          [this.assetA, this.assetB] = normalizeAssets(nonADAAssets[0].unit, nonADAAssets[1].unit);
          break;
        }
        default:
          throw new Error("pool must have 2 or 3 assets except factory, NFT and LP tokens");
      }
    }
    get nft() {
      const nft = this.value.find(({ unit }) => unit.startsWith(DexV1Constant.POOL_NFT_POLICY_ID));
      invariant(nft, "pool doesn't have NFT");
      return nft.unit;
    }
    get id() {
      return this.nft.slice(DexV1Constant.POOL_NFT_POLICY_ID.length);
    }
    get assetLP() {
      return `${DexV1Constant.LP_POLICY_ID}${this.id}`;
    }
    get reserveA() {
      return BigInt(this.value.find(({ unit }) => unit === this.assetA)?.quantity ?? "0");
    }
    get reserveB() {
      return BigInt(this.value.find(({ unit }) => unit === this.assetB)?.quantity ?? "0");
    }
  }
  PoolV12.State = State;
  ((Datum2) => {
    function toPlutusData(datum) {
      const { assetA, assetB, totalLiquidity, rootKLast, feeSharing } = datum;
      return new Constr(0, [
        Asset.toPlutusData(assetA),
        Asset.toPlutusData(assetB),
        totalLiquidity,
        rootKLast,
        feeSharing ? new Constr(0, [PoolFeeSharing.toPlutusData(feeSharing)]) : new Constr(1, [])
      ]);
    }
    Datum2.toPlutusData = toPlutusData;
    function fromPlutusData(networkId, data) {
      if (data.index !== 0) {
        throw new Error(`Index of Pool Datum must be 0, actual: ${data.index}`);
      }
      let feeSharing = void 0;
      const maybeFeeSharingConstr = data.fields[4];
      switch (maybeFeeSharingConstr.index) {
        case 0: {
          feeSharing = PoolFeeSharing.fromPlutusData(networkId, maybeFeeSharingConstr.fields[0]);
          break;
        }
        case 1: {
          feeSharing = void 0;
          break;
        }
        default: {
          throw new Error(`Index of Pool Fee Sharing must be 0 or 1, actual: ${maybeFeeSharingConstr.index}`);
        }
      }
      return {
        assetA: Asset.fromPlutusData(data.fields[0]),
        assetB: Asset.fromPlutusData(data.fields[1]),
        totalLiquidity: data.fields[2],
        rootKLast: data.fields[3],
        feeSharing
      };
    }
    Datum2.fromPlutusData = fromPlutusData;
  })(PoolV12.Datum || (PoolV12.Datum = {}));
})(PoolV1 || (PoolV1 = {}));
var StablePool;
((StablePool2) => {
  class State {
    address;
    txIn;
    value;
    datumCbor;
    datum;
    config;
    constructor(networkId, address, txIn, value, datum) {
      this.address = address;
      this.txIn = txIn;
      this.value = value;
      this.datumCbor = datum;
      this.datum = Datum.fromPlutusData(Data.from(datum));
      const allConfigs = StableswapConstant.CONFIG[networkId];
      const config = allConfigs.find((cfg) => cfg.poolAddress === address);
      if (!config) {
        throw new Error("Invalid Stable Pool address");
      }
      this.config = config;
      if (!value.find((v) => v.unit === config.nftAsset && v.quantity === "1")) {
        throw new Error("Cannot find the Pool NFT in the value");
      }
    }
    get assets() {
      return this.config.assets;
    }
    get nft() {
      return this.config.nftAsset;
    }
    get lpAsset() {
      return this.config.lpAsset;
    }
    get reserves() {
      return this.datum.balances;
    }
    get totalLiquidity() {
      return this.datum.totalLiquidity;
    }
    get orderHash() {
      return this.datum.orderHash;
    }
    get amp() {
      return this.datum.amplificationCoefficient;
    }
    get id() {
      return this.nft;
    }
  }
  StablePool2.State = State;
  let Datum;
  ((Datum2) => {
    function toPlutusData(datum) {
      const { balances, totalLiquidity, amplificationCoefficient, orderHash } = datum;
      return new Constr(0, [
        balances,
        totalLiquidity,
        amplificationCoefficient,
        orderHash
      ]);
    }
    Datum2.toPlutusData = toPlutusData;
    function fromPlutusData(data) {
      if (data.index !== 0) {
        throw new Error(`Index of Pool Datum must be 0, actual: ${data.index}`);
      }
      return {
        balances: data.fields[0],
        totalLiquidity: data.fields[1],
        amplificationCoefficient: data.fields[2],
        orderHash: data.fields[3]
      };
    }
    Datum2.fromPlutusData = fromPlutusData;
  })(Datum = StablePool2.Datum || (StablePool2.Datum = {}));
})(StablePool || (StablePool = {}));
var PoolV2;
((PoolV22) => {
  PoolV22.MAX_LIQUIDITY = 9223372036854775807n;
  PoolV22.DEFAULT_POOL_ADA = 4500000n;
  PoolV22.MINIMUM_LIQUIDITY = 10n;
  PoolV22.DEFAULT_TRADING_FEE_DENOMINATOR = 10000n;
  function computeLPAssetName(assetA, assetB) {
    const k1 = sha3(assetA.policyId + assetA.tokenName);
    const k2 = sha3(assetB.policyId + assetB.tokenName);
    return sha3(k1 + k2);
  }
  PoolV22.computeLPAssetName = computeLPAssetName;
  class State {
    address;
    txIn;
    value;
    datumRaw;
    datum;
    config;
    lpAsset;
    authenAsset;
    constructor(networkId, address, txIn, value, datum) {
      this.address = address;
      this.txIn = txIn;
      this.value = value;
      this.datumRaw = datum;
      this.datum = Datum.fromPlutusData(Data.from(datum));
      this.config = DexV2Constant.CONFIG[networkId];
      this.lpAsset = {
        policyId: this.config.lpPolicyId,
        tokenName: computeLPAssetName(this.datum.assetA, this.datum.assetB)
      };
      this.authenAsset = Asset.fromString(this.config.poolAuthenAsset);
      if (!value.find((v) => v.unit === this.config.poolAuthenAsset && v.quantity === "1")) {
        throw new Error("Cannot find the Pool Authentication Asset in the value");
      }
    }
    get assetA() {
      return Asset.toString(this.datum.assetA);
    }
    get assetB() {
      return Asset.toString(this.datum.assetB);
    }
    get totalLiquidity() {
      return this.datum.totalLiquidity;
    }
    get reserveA() {
      return this.datum.reserveA;
    }
    get reserveB() {
      return this.datum.reserveB;
    }
    get feeA() {
      return [
        this.datum.baseFee.feeANumerator,
        DEFAULT_POOL_V2_TRADING_FEE_DENOMINATOR
      ];
    }
    get feeB() {
      return [
        this.datum.baseFee.feeBNumerator,
        DEFAULT_POOL_V2_TRADING_FEE_DENOMINATOR
      ];
    }
    get feeShare() {
      if (this.datum.feeSharingNumerator !== void 0) {
        return [
          this.datum.feeSharingNumerator,
          DEFAULT_POOL_V2_TRADING_FEE_DENOMINATOR
        ];
      } else {
        return void 0;
      }
    }
    get datumReserves() {
      return [this.datum.reserveA, this.datum.reserveB];
    }
    get valueReserveA() {
      const amount = BigInt(this.value.find((v) => v.unit === this.assetA)?.quantity ?? "0");
      if (Asset.equals(this.datum.assetA, ADA)) {
        return amount - PoolV22.DEFAULT_POOL_ADA;
      }
      return amount;
    }
    get valueReserveB() {
      return BigInt(this.value.find((v) => v.unit === this.assetB)?.quantity ?? "0");
    }
    get valueReserves() {
      return [this.valueReserveA, this.valueReserveB];
    }
    get info() {
      return {
        datumReserves: this.datumReserves,
        valueReserves: this.valueReserves,
        totalLiquidity: this.datum.totalLiquidity,
        tradingFee: this.datum.baseFee,
        feeSharingNumerator: this.datum.feeSharingNumerator
      };
    }
  }
  PoolV22.State = State;
  let Datum;
  ((Datum2) => {
    function toPlutusData(datum) {
      const {
        poolBatchingStakeCredential,
        assetA,
        assetB,
        totalLiquidity,
        reserveA,
        reserveB,
        baseFee,
        feeSharingNumerator,
        allowDynamicFee
      } = datum;
      return new Constr(0, [
        new Constr(0, [LucidCredential.toPlutusData(poolBatchingStakeCredential)]),
        Asset.toPlutusData(assetA),
        Asset.toPlutusData(assetB),
        totalLiquidity,
        reserveA,
        reserveB,
        baseFee.feeANumerator,
        baseFee.feeBNumerator,
        feeSharingNumerator !== void 0 ? new Constr(0, [feeSharingNumerator]) : new Constr(1, []),
        new Constr(allowDynamicFee ? 1 : 0, [])
      ]);
    }
    Datum2.toPlutusData = toPlutusData;
    function fromPlutusData(data) {
      if (data.index !== 0) {
        throw new Error(`Index of Pool Datum must be 0, actual: ${data.index}`);
      }
      const stakeCredentialConstr = data.fields[0];
      if (stakeCredentialConstr.index !== 0) {
        throw new Error(`Index of Stake Credential must be 0, actual: ${stakeCredentialConstr.index}`);
      }
      let feeSharingNumerator = void 0;
      const maybeFeeSharingConstr = data.fields[8];
      switch (maybeFeeSharingConstr.index) {
        case 0: {
          feeSharingNumerator = maybeFeeSharingConstr.fields[0];
          break;
        }
        case 1: {
          feeSharingNumerator = void 0;
          break;
        }
        default: {
          throw new Error(`Index of Pool Fee Sharing must be 0 or 1, actual: ${maybeFeeSharingConstr.index}`);
        }
      }
      const allowDynamicFeeConstr = data.fields[9];
      const allowDynamicFee = allowDynamicFeeConstr.index === 1;
      return {
        poolBatchingStakeCredential: LucidCredential.fromPlutusData(stakeCredentialConstr.fields[0]),
        assetA: Asset.fromPlutusData(data.fields[1]),
        assetB: Asset.fromPlutusData(data.fields[2]),
        totalLiquidity: data.fields[3],
        reserveA: data.fields[4],
        reserveB: data.fields[5],
        baseFee: {
          feeANumerator: data.fields[6],
          feeBNumerator: data.fields[7]
        },
        feeSharingNumerator,
        allowDynamicFee
      };
    }
    Datum2.fromPlutusData = fromPlutusData;
  })(Datum = PoolV22.Datum || (PoolV22.Datum = {}));
})(PoolV2 || (PoolV2 = {}));

class BlockfrostAdapter {
  api;
  networkId;
  constructor({ networkId, blockFrost }) {
    this.networkId = networkId;
    this.api = blockFrost;
  }
  async getV1Pools({
    page,
    count = 100,
    order = "asc"
  }) {
    const utxos = await this.api.addressesUtxos(DexV1Constant.POOL_SCRIPT_HASH, {
      count,
      order,
      page
    });
    return utxos.filter((utxo) => isValidPoolOutput(utxo.address, utxo.amount, utxo.data_hash)).map((utxo) => {
      invariant(utxo.data_hash, `expect pool to have datum hash, got ${utxo.data_hash}`);
      return new PoolV1.State(utxo.address, { txHash: utxo.tx_hash, index: utxo.output_index }, utxo.amount, utxo.data_hash);
    });
  }
  async getV1PoolById({
    id
  }) {
    const nft = `${DexV1Constant.POOL_NFT_POLICY_ID}${id}`;
    const nftTxs = await this.api.assetsTransactions(nft, {
      count: 1,
      page: 1,
      order: "desc"
    });
    if (nftTxs.length === 0) {
      return null;
    }
    return this.getV1PoolInTx({ txHash: nftTxs[0].tx_hash });
  }
  async getV1PoolHistory({
    id,
    page = 1,
    count = 100,
    order = "desc"
  }) {
    const nft = `${DexV1Constant.POOL_NFT_POLICY_ID}${id}`;
    const nftTxs = await this.api.assetsTransactions(nft, {
      count,
      page,
      order
    });
    return nftTxs.map((tx) => ({
      txHash: tx.tx_hash,
      txIndex: tx.tx_index,
      blockHeight: tx.block_height,
      time: new Date(Number(tx.block_time) * 1e3)
    }));
  }
  async getV1PoolInTx({
    txHash
  }) {
    const poolTx = await this.api.txsUtxos(txHash);
    const poolUtxo = poolTx.outputs.find((o) => getScriptHashFromAddress(o.address) === DexV1Constant.POOL_SCRIPT_HASH);
    if (!poolUtxo) {
      return null;
    }
    checkValidPoolOutput(poolUtxo.address, poolUtxo.amount, poolUtxo.data_hash);
    invariant(poolUtxo.data_hash, `expect pool to have datum hash, got ${poolUtxo.data_hash}`);
    return new PoolV1.State(poolUtxo.address, { txHash, index: poolUtxo.output_index }, poolUtxo.amount, poolUtxo.data_hash);
  }
  async getAssetDecimals(asset) {
    if (asset === "lovelace") {
      return 6;
    }
    try {
      const assetAInfo = await this.api.assetsById(asset);
      return assetAInfo.metadata?.decimals ?? 0;
    } catch (err) {
      if (err instanceof BlockfrostServerError && err.status_code === 404) {
        return 0;
      }
      throw err;
    }
  }
  async getV1PoolPrice({
    pool,
    decimalsA,
    decimalsB
  }) {
    if (decimalsA === void 0) {
      decimalsA = await this.getAssetDecimals(pool.assetA);
    }
    if (decimalsB === void 0) {
      decimalsB = await this.getAssetDecimals(pool.assetB);
    }
    const adjustedReserveA = Big(pool.reserveA.toString()).div(Big(10).pow(decimalsA));
    const adjustedReserveB = Big(pool.reserveB.toString()).div(Big(10).pow(decimalsB));
    const priceAB = adjustedReserveA.div(adjustedReserveB);
    const priceBA = adjustedReserveB.div(adjustedReserveA);
    return [priceAB, priceBA];
  }
  async getDatumByDatumHash(datumHash) {
    const scriptsDatum = await this.api.scriptsDatumCbor(datumHash);
    return scriptsDatum.cbor;
  }
  async getAllV2Pools() {
    const v2Config = DexV2Constant.CONFIG[this.networkId];
    const utxos = await this.api.addressesUtxosAssetAll(v2Config.poolScriptHashBech32, v2Config.poolAuthenAsset);
    const pools = [];
    const errors = [];
    for (const utxo of utxos) {
      try {
        if (!utxo.inline_datum) {
          throw new Error(`Cannot find datum of Pool V2, tx: ${utxo.tx_hash}`);
        }
        const pool = new PoolV2.State(this.networkId, utxo.address, { txHash: utxo.tx_hash, index: utxo.output_index }, utxo.amount, utxo.inline_datum);
        pools.push(pool);
      } catch (err) {
        errors.push(err);
      }
    }
    return {
      pools,
      errors
    };
  }
  async getV2Pools({
    page,
    count = 100,
    order = "asc"
  }) {
    const v2Config = DexV2Constant.CONFIG[this.networkId];
    const utxos = await this.api.addressesUtxosAsset(v2Config.poolScriptHashBech32, v2Config.poolAuthenAsset, {
      count,
      order,
      page
    });
    const pools = [];
    const errors = [];
    for (const utxo of utxos) {
      try {
        if (!utxo.inline_datum) {
          throw new Error(`Cannot find datum of Pool V2, tx: ${utxo.tx_hash}`);
        }
        const pool = new PoolV2.State(this.networkId, utxo.address, { txHash: utxo.tx_hash, index: utxo.output_index }, utxo.amount, utxo.inline_datum);
        pools.push(pool);
      } catch (err) {
        errors.push(err);
      }
    }
    return {
      pools,
      errors
    };
  }
  async getV2PoolByPair(assetA, assetB) {
    const [normalizedAssetA, normalizedAssetB] = normalizeAssets(Asset.toString(assetA), Asset.toString(assetB));
    const { pools: allPools } = await this.getAllV2Pools();
    return allPools.find((pool) => pool.assetA === normalizedAssetA && pool.assetB === normalizedAssetB) ?? null;
  }
  async getV2PoolByLp(lpAsset) {
    const { pools: allPools } = await this.getAllV2Pools();
    return allPools.find((pool) => Asset.compare(pool.lpAsset, lpAsset) === 0) ?? null;
  }
  async getV2PoolPrice({
    pool,
    decimalsA,
    decimalsB
  }) {
    if (decimalsA === void 0) {
      decimalsA = await this.getAssetDecimals(pool.assetA);
    }
    if (decimalsB === void 0) {
      decimalsB = await this.getAssetDecimals(pool.assetB);
    }
    const adjustedReserveA = Big(pool.reserveA.toString()).div(Big(10).pow(decimalsA));
    const adjustedReserveB = Big(pool.reserveB.toString()).div(Big(10).pow(decimalsB));
    const priceAB = adjustedReserveA.div(adjustedReserveB);
    const priceBA = adjustedReserveB.div(adjustedReserveA);
    return [priceAB, priceBA];
  }
  async getAllStablePools() {
    const poolAddresses = StableswapConstant.CONFIG[this.networkId].map((cfg) => cfg.poolAddress);
    const pools = [];
    const errors = [];
    for (const poolAddr of poolAddresses) {
      const utxos = await this.api.addressesUtxosAll(poolAddr);
      try {
        for (const utxo of utxos) {
          let datum;
          if (utxo.inline_datum) {
            datum = utxo.inline_datum;
          } else if (utxo.data_hash) {
            datum = await this.getDatumByDatumHash(utxo.data_hash);
          } else {
            throw new Error("Cannot find datum of Stable Pool");
          }
          const pool = new StablePool.State(this.networkId, utxo.address, { txHash: utxo.tx_hash, index: utxo.output_index }, utxo.amount, datum);
          pools.push(pool);
        }
      } catch (err) {
        errors.push(err);
      }
    }
    return {
      pools,
      errors
    };
  }
  async getStablePoolByNFT(nft) {
    const poolAddress = StableswapConstant.CONFIG[this.networkId].find((cfg) => cfg.nftAsset === Asset.toString(nft))?.poolAddress;
    if (!poolAddress) {
      throw new Error(`Cannot find Stable Pool having NFT ${Asset.toString(nft)}`);
    }
    const utxos = await this.api.addressesUtxosAssetAll(poolAddress, Asset.toString(nft));
    for (const utxo of utxos) {
      let datum;
      if (utxo.inline_datum) {
        datum = utxo.inline_datum;
      } else if (utxo.data_hash) {
        datum = await this.getDatumByDatumHash(utxo.data_hash);
      } else {
        throw new Error("Cannot find datum of Stable Pool");
      }
      const pool = new StablePool.State(this.networkId, utxo.address, { txHash: utxo.tx_hash, index: utxo.output_index }, utxo.amount, datum);
      return pool;
    }
    return null;
  }
  async getAllFactoriesV2() {
    const v2Config = DexV2Constant.CONFIG[this.networkId];
    const utxos = await this.api.addressesUtxosAssetAll(v2Config.factoryScriptHashBech32, v2Config.factoryAsset);
    const factories = [];
    const errors = [];
    for (const utxo of utxos) {
      try {
        if (!utxo.inline_datum) {
          throw new Error(`Cannot find datum of Factory V2, tx: ${utxo.tx_hash}`);
        }
        const factory = new FactoryV2.State(this.networkId, utxo.address, { txHash: utxo.tx_hash, index: utxo.output_index }, utxo.amount, utxo.inline_datum);
        factories.push(factory);
      } catch (err) {
        errors.push(err);
      }
    }
    return {
      factories,
      errors
    };
  }
  async getFactoryV2ByPair(assetA, assetB) {
    const factoryIdent = PoolV2.computeLPAssetName(assetA, assetB);
    const { factories: allFactories } = await this.getAllFactoriesV2();
    for (const factory of allFactories) {
      if (StringUtils.compare(factory.head, factoryIdent) < 0 && StringUtils.compare(factoryIdent, factory.tail) < 0) {
        return factory;
      }
    }
    return null;
  }
}

var OrderV1;
((OrderV12) => {
  ((StepType2) => {
    StepType2[StepType2["SWAP_EXACT_IN"] = 0] = "SWAP_EXACT_IN";
    StepType2[StepType2["SWAP_EXACT_OUT"] = 1] = "SWAP_EXACT_OUT";
    StepType2[StepType2["DEPOSIT"] = 2] = "DEPOSIT";
    StepType2[StepType2["WITHDRAW"] = 3] = "WITHDRAW";
    StepType2[StepType2["ZAP_IN"] = 4] = "ZAP_IN";
  })(OrderV12.StepType || (OrderV12.StepType = {}));
  ((Datum2) => {
    function toPlutusData(datum) {
      const {
        sender,
        receiver,
        receiverDatumHash,
        step,
        batcherFee,
        depositADA
      } = datum;
      const senderConstr = AddressPlutusData.toPlutusData(sender);
      const receiverConstr = AddressPlutusData.toPlutusData(receiver);
      const receiverDatumHashConstr = receiverDatumHash ? new Constr(0, [receiverDatumHash]) : new Constr(1, []);
      let datumConstr;
      switch (step.type) {
        case 0 /* SWAP_EXACT_IN */: {
          datumConstr = new Constr(0, [
            senderConstr,
            receiverConstr,
            receiverDatumHashConstr,
            new Constr(0 /* SWAP_EXACT_IN */, [
              Asset.toPlutusData(step.desiredAsset),
              step.minimumReceived
            ]),
            batcherFee,
            depositADA
          ]);
          break;
        }
        case 1 /* SWAP_EXACT_OUT */: {
          datumConstr = new Constr(0, [
            senderConstr,
            receiverConstr,
            receiverDatumHashConstr,
            new Constr(1 /* SWAP_EXACT_OUT */, [
              Asset.toPlutusData(step.desiredAsset),
              step.expectedReceived
            ]),
            batcherFee,
            depositADA
          ]);
          break;
        }
        case 2 /* DEPOSIT */: {
          datumConstr = new Constr(0, [
            senderConstr,
            receiverConstr,
            receiverDatumHashConstr,
            new Constr(2 /* DEPOSIT */, [step.minimumLP]),
            batcherFee,
            depositADA
          ]);
          break;
        }
        case 3 /* WITHDRAW */: {
          datumConstr = new Constr(0, [
            senderConstr,
            receiverConstr,
            receiverDatumHashConstr,
            new Constr(3 /* WITHDRAW */, [
              step.minimumAssetA,
              step.minimumAssetB
            ]),
            batcherFee,
            depositADA
          ]);
          break;
        }
        case 4 /* ZAP_IN */: {
          datumConstr = new Constr(0, [
            senderConstr,
            receiverConstr,
            receiverDatumHashConstr,
            new Constr(4 /* ZAP_IN */, [
              Asset.toPlutusData(step.desiredAsset),
              step.minimumLP
            ]),
            batcherFee,
            depositADA
          ]);
          break;
        }
      }
      return datumConstr;
    }
    Datum2.toPlutusData = toPlutusData;
    function fromPlutusData(networkId, data) {
      if (data.index !== 0) {
        throw new Error(`Index of Order Datum must be 0, actual: ${data.index}`);
      }
      const sender = AddressPlutusData.fromPlutusData(networkId, data.fields[0]);
      const receiver = AddressPlutusData.fromPlutusData(networkId, data.fields[1]);
      let receiverDatumHash = void 0;
      const maybeReceiverDatumHash = data.fields[2];
      switch (maybeReceiverDatumHash.index) {
        case 0: {
          receiverDatumHash = maybeReceiverDatumHash.fields[0];
          break;
        }
        case 1: {
          receiverDatumHash = void 0;
          break;
        }
        default: {
          throw new Error(`Index of Receiver Datum Hash must be 0 or 1, actual: ${maybeReceiverDatumHash.index}`);
        }
      }
      let step;
      const orderStepConstr = data.fields[3];
      switch (orderStepConstr.index) {
        case 0 /* SWAP_EXACT_IN */: {
          step = {
            type: 0 /* SWAP_EXACT_IN */,
            desiredAsset: Asset.fromPlutusData(orderStepConstr.fields[0]),
            minimumReceived: orderStepConstr.fields[1]
          };
          break;
        }
        case 1 /* SWAP_EXACT_OUT */: {
          step = {
            type: 1 /* SWAP_EXACT_OUT */,
            desiredAsset: Asset.fromPlutusData(orderStepConstr.fields[0]),
            expectedReceived: orderStepConstr.fields[1]
          };
          break;
        }
        case 2 /* DEPOSIT */: {
          step = {
            type: 2 /* DEPOSIT */,
            minimumLP: orderStepConstr.fields[0]
          };
          break;
        }
        case 3 /* WITHDRAW */: {
          step = {
            type: 3 /* WITHDRAW */,
            minimumAssetA: orderStepConstr.fields[0],
            minimumAssetB: orderStepConstr.fields[1]
          };
          break;
        }
        case 4 /* ZAP_IN */: {
          step = {
            type: 4 /* ZAP_IN */,
            desiredAsset: Asset.fromPlutusData(orderStepConstr.fields[0]),
            minimumLP: orderStepConstr.fields[1]
          };
          break;
        }
        default: {
          throw new Error(`Index of Order Step must be in 0-4, actual: ${orderStepConstr.index}`);
        }
      }
      const batcherFee = data.fields[4];
      const depositADA = data.fields[5];
      return {
        sender,
        receiver,
        receiverDatumHash,
        step,
        batcherFee,
        depositADA
      };
    }
    Datum2.fromPlutusData = fromPlutusData;
  })(OrderV12.Datum || (OrderV12.Datum = {}));
  ((Redeemer2) => {
    Redeemer2[Redeemer2["APPLY_ORDER"] = 0] = "APPLY_ORDER";
    Redeemer2[Redeemer2["CANCEL_ORDER"] = 1] = "CANCEL_ORDER";
  })(OrderV12.Redeemer || (OrderV12.Redeemer = {}));
})(OrderV1 || (OrderV1 = {}));
var StableOrder;
((StableOrder2) => {
  ((StepType2) => {
    StepType2[StepType2["SWAP"] = 0] = "SWAP";
    StepType2[StepType2["DEPOSIT"] = 1] = "DEPOSIT";
    StepType2[StepType2["WITHDRAW"] = 2] = "WITHDRAW";
    StepType2[StepType2["WITHDRAW_IMBALANCE"] = 3] = "WITHDRAW_IMBALANCE";
    StepType2[StepType2["ZAP_OUT"] = 4] = "ZAP_OUT";
  })(StableOrder2.StepType || (StableOrder2.StepType = {}));
  ((Datum2) => {
    function toPlutusData(datum) {
      const {
        sender,
        receiver,
        receiverDatumHash,
        step,
        batcherFee,
        depositADA
      } = datum;
      const senderConstr = AddressPlutusData.toPlutusData(sender);
      const receiverConstr = AddressPlutusData.toPlutusData(receiver);
      const receiverDatumHashConstr = receiverDatumHash ? new Constr(0, [receiverDatumHash]) : new Constr(1, []);
      let stepConstr;
      switch (step.type) {
        case 0 /* SWAP */: {
          stepConstr = new Constr(0 /* SWAP */, [
            step.assetInIndex,
            step.assetOutIndex,
            step.minimumAssetOut
          ]);
          break;
        }
        case 1 /* DEPOSIT */: {
          stepConstr = new Constr(1 /* DEPOSIT */, [step.minimumLP]);
          break;
        }
        case 2 /* WITHDRAW */: {
          stepConstr = new Constr(2 /* WITHDRAW */, [step.minimumAmounts]);
          break;
        }
        case 3 /* WITHDRAW_IMBALANCE */: {
          stepConstr = new Constr(3 /* WITHDRAW_IMBALANCE */, [
            step.withdrawAmounts
          ]);
          break;
        }
        case 4 /* ZAP_OUT */: {
          stepConstr = new Constr(4 /* ZAP_OUT */, [
            step.assetOutIndex,
            step.minimumAssetOut
          ]);
          break;
        }
      }
      return new Constr(0, [
        senderConstr,
        receiverConstr,
        receiverDatumHashConstr,
        stepConstr,
        batcherFee,
        depositADA
      ]);
    }
    Datum2.toPlutusData = toPlutusData;
    function fromPlutusData(networkId, data) {
      if (data.index !== 0) {
        throw new Error(`Index of Order Datum must be 0, actual: ${data.index}`);
      }
      const sender = AddressPlutusData.fromPlutusData(networkId, data.fields[0]);
      const receiver = AddressPlutusData.fromPlutusData(networkId, data.fields[1]);
      let receiverDatumHash = void 0;
      const maybeReceiverDatumHash = data.fields[2];
      switch (maybeReceiverDatumHash.index) {
        case 0: {
          receiverDatumHash = maybeReceiverDatumHash.fields[0];
          break;
        }
        case 1: {
          receiverDatumHash = void 0;
          break;
        }
        default: {
          throw new Error(`Index of Receiver Datum Hash must be 0 or 1, actual: ${maybeReceiverDatumHash.index}`);
        }
      }
      let step;
      const orderStepConstr = data.fields[3];
      switch (orderStepConstr.index) {
        case 0 /* SWAP */: {
          step = {
            type: 0 /* SWAP */,
            assetInIndex: orderStepConstr.fields[0],
            assetOutIndex: orderStepConstr.fields[1],
            minimumAssetOut: orderStepConstr.fields[2]
          };
          break;
        }
        case 1 /* DEPOSIT */: {
          step = {
            type: 1 /* DEPOSIT */,
            minimumLP: orderStepConstr.fields[0]
          };
          break;
        }
        case 2 /* WITHDRAW */: {
          step = {
            type: 2 /* WITHDRAW */,
            minimumAmounts: orderStepConstr.fields[0]
          };
          break;
        }
        case 3 /* WITHDRAW_IMBALANCE */: {
          step = {
            type: 3 /* WITHDRAW_IMBALANCE */,
            withdrawAmounts: orderStepConstr.fields[0]
          };
          break;
        }
        case 4 /* ZAP_OUT */: {
          step = {
            type: 4 /* ZAP_OUT */,
            assetOutIndex: orderStepConstr.fields[0],
            minimumAssetOut: orderStepConstr.fields[1]
          };
          break;
        }
        default: {
          throw new Error(`Index of Order Step must be in 0-4, actual: ${orderStepConstr.index}`);
        }
      }
      const batcherFee = data.fields[4];
      const depositADA = data.fields[5];
      return {
        sender,
        receiver,
        receiverDatumHash,
        step,
        batcherFee,
        depositADA
      };
    }
    Datum2.fromPlutusData = fromPlutusData;
  })(StableOrder2.Datum || (StableOrder2.Datum = {}));
  ((Redeemer2) => {
    Redeemer2[Redeemer2["APPLY_ORDER"] = 0] = "APPLY_ORDER";
    Redeemer2[Redeemer2["CANCEL_ORDER"] = 1] = "CANCEL_ORDER";
  })(StableOrder2.Redeemer || (StableOrder2.Redeemer = {}));
})(StableOrder || (StableOrder = {}));
var OrderV2;
((OrderV22) => {
  ((AuthorizationMethodType2) => {
    AuthorizationMethodType2[AuthorizationMethodType2["SIGNATURE"] = 0] = "SIGNATURE";
    AuthorizationMethodType2[AuthorizationMethodType2["SPEND_SCRIPT"] = 1] = "SPEND_SCRIPT";
    AuthorizationMethodType2[AuthorizationMethodType2["WITHDRAW_SCRIPT"] = 2] = "WITHDRAW_SCRIPT";
    AuthorizationMethodType2[AuthorizationMethodType2["MINT_SCRIPT"] = 3] = "MINT_SCRIPT";
  })(OrderV22.AuthorizationMethodType || (OrderV22.AuthorizationMethodType = {}));
  let AuthorizationMethod;
  ((AuthorizationMethod2) => {
    function fromPlutusData(data) {
      let type;
      switch (data.index) {
        case 0 /* SIGNATURE */: {
          type = 0 /* SIGNATURE */;
          break;
        }
        case 1 /* SPEND_SCRIPT */: {
          type = 1 /* SPEND_SCRIPT */;
          break;
        }
        case 2 /* WITHDRAW_SCRIPT */: {
          type = 2 /* WITHDRAW_SCRIPT */;
          break;
        }
        case 3 /* MINT_SCRIPT */: {
          type = 3 /* MINT_SCRIPT */;
          break;
        }
        default: {
          throw new Error(`Index of AuthorizationMethod must be in 0-3, actual: ${data.index}`);
        }
      }
      return {
        type,
        hash: data.fields[0]
      };
    }
    AuthorizationMethod2.fromPlutusData = fromPlutusData;
    function toPlutusData(method) {
      return new Constr(method.type, [method.hash]);
    }
    AuthorizationMethod2.toPlutusData = toPlutusData;
  })(AuthorizationMethod = OrderV22.AuthorizationMethod || (OrderV22.AuthorizationMethod = {}));
  let Direction;
  ((Direction2) => {
    Direction2[Direction2["B_TO_A"] = 0] = "B_TO_A";
    Direction2[Direction2["A_TO_B"] = 1] = "A_TO_B";
  })(Direction = OrderV22.Direction || (OrderV22.Direction = {}));
  ((Direction2) => {
    function fromPlutusData(data) {
      switch (data.index) {
        case 0 /* B_TO_A */: {
          return 0 /* B_TO_A */;
        }
        case 1 /* A_TO_B */: {
          return 1 /* A_TO_B */;
        }
        default: {
          throw new Error(`Index of Direction must be in 0-1, actual: ${data.index}`);
        }
      }
    }
    Direction2.fromPlutusData = fromPlutusData;
    function toPlutusData(direction) {
      return new Constr(direction, []);
    }
    Direction2.toPlutusData = toPlutusData;
  })(Direction = OrderV22.Direction || (OrderV22.Direction = {}));
  let Killable;
  ((Killable2) => {
    Killable2[Killable2["PENDING_ON_FAILED"] = 0] = "PENDING_ON_FAILED";
    Killable2[Killable2["KILL_ON_FAILED"] = 1] = "KILL_ON_FAILED";
  })(Killable = OrderV22.Killable || (OrderV22.Killable = {}));
  ((Killable2) => {
    function fromPlutusData(data) {
      switch (data.index) {
        case 0 /* PENDING_ON_FAILED */: {
          return 0 /* PENDING_ON_FAILED */;
        }
        case 1 /* KILL_ON_FAILED */: {
          return 1 /* KILL_ON_FAILED */;
        }
        default: {
          throw new Error(`Index of Killable must be in 0-1, actual: ${data.index}`);
        }
      }
    }
    Killable2.fromPlutusData = fromPlutusData;
    function toPlutusData(killable) {
      return new Constr(killable, []);
    }
    Killable2.toPlutusData = toPlutusData;
  })(Killable = OrderV22.Killable || (OrderV22.Killable = {}));
  ((AmountType2) => {
    AmountType2[AmountType2["SPECIFIC_AMOUNT"] = 0] = "SPECIFIC_AMOUNT";
    AmountType2[AmountType2["ALL"] = 1] = "ALL";
  })(OrderV22.AmountType || (OrderV22.AmountType = {}));
  let DepositAmount;
  ((DepositAmount2) => {
    function fromPlutusData(data) {
      switch (data.index) {
        case 0 /* SPECIFIC_AMOUNT */: {
          return {
            type: 0 /* SPECIFIC_AMOUNT */,
            depositAmountA: data.fields[0],
            depositAmountB: data.fields[1]
          };
        }
        case 1 /* ALL */: {
          return {
            type: 1 /* ALL */,
            deductedAmountA: data.fields[0],
            deductedAmountB: data.fields[1]
          };
        }
        default: {
          throw new Error(`Index of DepositAmount must be in 0-1, actual: ${data.index}`);
        }
      }
    }
    DepositAmount2.fromPlutusData = fromPlutusData;
    function toPlutusData(amount) {
      switch (amount.type) {
        case 0 /* SPECIFIC_AMOUNT */: {
          return new Constr(0 /* SPECIFIC_AMOUNT */, [
            amount.depositAmountA,
            amount.depositAmountB
          ]);
        }
        case 1 /* ALL */: {
          return new Constr(1 /* ALL */, [
            amount.deductedAmountA,
            amount.deductedAmountB
          ]);
        }
      }
    }
    DepositAmount2.toPlutusData = toPlutusData;
  })(DepositAmount = OrderV22.DepositAmount || (OrderV22.DepositAmount = {}));
  let SwapAmount;
  ((SwapAmount2) => {
    function fromPlutusData(data) {
      switch (data.index) {
        case 0 /* SPECIFIC_AMOUNT */: {
          return {
            type: 0 /* SPECIFIC_AMOUNT */,
            swapAmount: data.fields[0]
          };
        }
        case 1 /* ALL */: {
          return {
            type: 1 /* ALL */,
            deductedAmount: data.fields[0]
          };
        }
        default: {
          throw new Error(`Index of SwapAmount must be in 0-1, actual: ${data.index}`);
        }
      }
    }
    SwapAmount2.fromPlutusData = fromPlutusData;
    function toPlutusData(amount) {
      switch (amount.type) {
        case 0 /* SPECIFIC_AMOUNT */: {
          return new Constr(0 /* SPECIFIC_AMOUNT */, [amount.swapAmount]);
        }
        case 1 /* ALL */: {
          return new Constr(1 /* ALL */, [amount.deductedAmount]);
        }
      }
    }
    SwapAmount2.toPlutusData = toPlutusData;
  })(SwapAmount = OrderV22.SwapAmount || (OrderV22.SwapAmount = {}));
  let WithdrawAmount;
  ((WithdrawAmount2) => {
    function fromPlutusData(data) {
      switch (data.index) {
        case 0 /* SPECIFIC_AMOUNT */: {
          return {
            type: 0 /* SPECIFIC_AMOUNT */,
            withdrawalLPAmount: data.fields[0]
          };
        }
        case 1 /* ALL */: {
          return {
            type: 1 /* ALL */,
            deductedLPAmount: data.fields[0]
          };
        }
        default: {
          throw new Error(`Index of WithdrawAmount must be in 0-1, actual: ${data.index}`);
        }
      }
    }
    WithdrawAmount2.fromPlutusData = fromPlutusData;
    function toPlutusData(amount) {
      switch (amount.type) {
        case 0 /* SPECIFIC_AMOUNT */: {
          return new Constr(0 /* SPECIFIC_AMOUNT */, [
            amount.withdrawalLPAmount
          ]);
        }
        case 1 /* ALL */: {
          return new Constr(1 /* ALL */, [amount.deductedLPAmount]);
        }
      }
    }
    WithdrawAmount2.toPlutusData = toPlutusData;
  })(WithdrawAmount = OrderV22.WithdrawAmount || (OrderV22.WithdrawAmount = {}));
  let Route;
  ((Route2) => {
    function fromPlutusData(data) {
      if (data.index !== 0) {
        throw new Error(`Index of Order Route must be 0, actual: ${data.index}`);
      }
      return {
        lpAsset: Asset.fromPlutusData(data.fields[0]),
        direction: Direction.fromPlutusData(data.fields[1])
      };
    }
    Route2.fromPlutusData = fromPlutusData;
    function toPlutusData(route) {
      return new Constr(0, [
        Asset.toPlutusData(route.lpAsset),
        Direction.toPlutusData(route.direction)
      ]);
    }
    Route2.toPlutusData = toPlutusData;
  })(Route = OrderV22.Route || (OrderV22.Route = {}));
  ((StepType2) => {
    StepType2[StepType2["SWAP_EXACT_IN"] = 0] = "SWAP_EXACT_IN";
    StepType2[StepType2["STOP"] = 1] = "STOP";
    StepType2[StepType2["OCO"] = 2] = "OCO";
    StepType2[StepType2["SWAP_EXACT_OUT"] = 3] = "SWAP_EXACT_OUT";
    StepType2[StepType2["DEPOSIT"] = 4] = "DEPOSIT";
    StepType2[StepType2["WITHDRAW"] = 5] = "WITHDRAW";
    StepType2[StepType2["ZAP_OUT"] = 6] = "ZAP_OUT";
    StepType2[StepType2["PARTIAL_SWAP"] = 7] = "PARTIAL_SWAP";
    StepType2[StepType2["WITHDRAW_IMBALANCE"] = 8] = "WITHDRAW_IMBALANCE";
    StepType2[StepType2["SWAP_ROUTING"] = 9] = "SWAP_ROUTING";
    StepType2[StepType2["DONATION"] = 10] = "DONATION";
  })(OrderV22.StepType || (OrderV22.StepType = {}));
  let Step;
  ((Step2) => {
    function fromPlutusData(data) {
      switch (data.index) {
        case 0 /* SWAP_EXACT_IN */: {
          return {
            type: 0 /* SWAP_EXACT_IN */,
            direction: Direction.fromPlutusData(data.fields[0]),
            swapAmount: SwapAmount.fromPlutusData(data.fields[1]),
            minimumReceived: data.fields[2],
            killable: Killable.fromPlutusData(data.fields[3])
          };
        }
        case 1 /* STOP */: {
          return {
            type: 1 /* STOP */,
            direction: Direction.fromPlutusData(data.fields[0]),
            swapAmount: SwapAmount.fromPlutusData(data.fields[1]),
            stopReceived: data.fields[2]
          };
        }
        case 2 /* OCO */: {
          return {
            type: 2 /* OCO */,
            direction: Direction.fromPlutusData(data.fields[0]),
            swapAmount: SwapAmount.fromPlutusData(data.fields[1]),
            minimumReceived: data.fields[2],
            stopReceived: data.fields[3]
          };
        }
        case 3 /* SWAP_EXACT_OUT */: {
          return {
            type: 3 /* SWAP_EXACT_OUT */,
            direction: Direction.fromPlutusData(data.fields[0]),
            maximumSwapAmount: SwapAmount.fromPlutusData(data.fields[1]),
            expectedReceived: data.fields[2],
            killable: Killable.fromPlutusData(data.fields[3])
          };
        }
        case 4 /* DEPOSIT */: {
          return {
            type: 4 /* DEPOSIT */,
            depositAmount: DepositAmount.fromPlutusData(data.fields[0]),
            minimumLP: data.fields[1],
            killable: Killable.fromPlutusData(data.fields[2])
          };
        }
        case 5 /* WITHDRAW */: {
          return {
            type: 5 /* WITHDRAW */,
            withdrawalAmount: WithdrawAmount.fromPlutusData(data.fields[0]),
            minimumAssetA: data.fields[1],
            minimumAssetB: data.fields[2],
            killable: Killable.fromPlutusData(data.fields[3])
          };
        }
        case 6 /* ZAP_OUT */: {
          return {
            type: 6 /* ZAP_OUT */,
            direction: Direction.fromPlutusData(data.fields[0]),
            withdrawalAmount: WithdrawAmount.fromPlutusData(data.fields[1]),
            minimumReceived: data.fields[2],
            killable: Killable.fromPlutusData(data.fields[3])
          };
        }
        case 7 /* PARTIAL_SWAP */: {
          return {
            type: 7 /* PARTIAL_SWAP */,
            direction: Direction.fromPlutusData(data.fields[0]),
            totalSwapAmount: data.fields[1],
            ioRatioNumerator: data.fields[2],
            ioRatioDenominator: data.fields[3],
            hops: data.fields[4],
            minimumSwapAmountRequired: data.fields[5],
            maxBatcherFeeEachTime: data.fields[6]
          };
        }
        case 8 /* WITHDRAW_IMBALANCE */: {
          return {
            type: 8 /* WITHDRAW_IMBALANCE */,
            withdrawalAmount: WithdrawAmount.fromPlutusData(data.fields[0]),
            ratioAssetA: data.fields[1],
            ratioAssetB: data.fields[2],
            minimumAssetA: data.fields[3],
            killable: Killable.fromPlutusData(data.fields[4])
          };
        }
        case 9 /* SWAP_ROUTING */: {
          return {
            type: 9 /* SWAP_ROUTING */,
            routings: data.fields[0].map(Route.fromPlutusData),
            swapAmount: SwapAmount.fromPlutusData(data.fields[1]),
            minimumReceived: data.fields[2]
          };
        }
        case 10 /* DONATION */: {
          return {
            type: 10 /* DONATION */
          };
        }
        default: {
          throw new Error(`Index of Step must be in 0-10, actual: ${data.index}`);
        }
      }
    }
    Step2.fromPlutusData = fromPlutusData;
    function toPlutusData(step) {
      switch (step.type) {
        case 0 /* SWAP_EXACT_IN */: {
          return new Constr(step.type, [
            Direction.toPlutusData(step.direction),
            SwapAmount.toPlutusData(step.swapAmount),
            step.minimumReceived,
            Killable.toPlutusData(step.killable)
          ]);
        }
        case 1 /* STOP */: {
          return new Constr(step.type, [
            Direction.toPlutusData(step.direction),
            SwapAmount.toPlutusData(step.swapAmount),
            step.stopReceived
          ]);
        }
        case 2 /* OCO */: {
          return new Constr(step.type, [
            Direction.toPlutusData(step.direction),
            SwapAmount.toPlutusData(step.swapAmount),
            step.minimumReceived,
            step.stopReceived
          ]);
        }
        case 3 /* SWAP_EXACT_OUT */: {
          return new Constr(step.type, [
            Direction.toPlutusData(step.direction),
            SwapAmount.toPlutusData(step.maximumSwapAmount),
            step.expectedReceived,
            Killable.toPlutusData(step.killable)
          ]);
        }
        case 4 /* DEPOSIT */: {
          return new Constr(step.type, [
            DepositAmount.toPlutusData(step.depositAmount),
            step.minimumLP,
            Killable.toPlutusData(step.killable)
          ]);
        }
        case 5 /* WITHDRAW */: {
          return new Constr(step.type, [
            WithdrawAmount.toPlutusData(step.withdrawalAmount),
            step.minimumAssetA,
            step.minimumAssetB,
            Killable.toPlutusData(step.killable)
          ]);
        }
        case 6 /* ZAP_OUT */: {
          return new Constr(step.type, [
            Direction.toPlutusData(step.direction),
            WithdrawAmount.toPlutusData(step.withdrawalAmount),
            step.minimumReceived,
            Killable.toPlutusData(step.killable)
          ]);
        }
        case 7 /* PARTIAL_SWAP */: {
          return new Constr(step.type, [
            Direction.toPlutusData(step.direction),
            step.totalSwapAmount,
            step.ioRatioNumerator,
            step.ioRatioDenominator,
            step.hops,
            step.minimumSwapAmountRequired,
            step.maxBatcherFeeEachTime
          ]);
        }
        case 8 /* WITHDRAW_IMBALANCE */: {
          return new Constr(step.type, [
            WithdrawAmount.toPlutusData(step.withdrawalAmount),
            step.ratioAssetA,
            step.ratioAssetB,
            step.minimumAssetA,
            Killable.toPlutusData(step.killable)
          ]);
        }
        case 9 /* SWAP_ROUTING */: {
          return new Constr(step.type, [
            step.routings.map(Route.toPlutusData),
            SwapAmount.toPlutusData(step.swapAmount),
            step.minimumReceived
          ]);
        }
        case 10 /* DONATION */: {
          return new Constr(step.type, []);
        }
      }
    }
    Step2.toPlutusData = toPlutusData;
  })(Step = OrderV22.Step || (OrderV22.Step = {}));
  ((ExtraDatumType2) => {
    ExtraDatumType2[ExtraDatumType2["NO_DATUM"] = 0] = "NO_DATUM";
    ExtraDatumType2[ExtraDatumType2["DATUM_HASH"] = 1] = "DATUM_HASH";
    ExtraDatumType2[ExtraDatumType2["INLINE_DATUM"] = 2] = "INLINE_DATUM";
  })(OrderV22.ExtraDatumType || (OrderV22.ExtraDatumType = {}));
  let ExtraDatum;
  ((ExtraDatum2) => {
    function fromPlutusData(data) {
      switch (data.index) {
        case 0 /* NO_DATUM */: {
          return {
            type: 0 /* NO_DATUM */
          };
        }
        case 1 /* DATUM_HASH */: {
          return {
            type: 1 /* DATUM_HASH */,
            hash: data.fields[0]
          };
        }
        case 2 /* INLINE_DATUM */: {
          return {
            type: 2 /* INLINE_DATUM */,
            hash: data.fields[0]
          };
        }
        default: {
          throw new Error(`Index of ExtraDatum must be in 0-2, actual: ${data.index}`);
        }
      }
    }
    ExtraDatum2.fromPlutusData = fromPlutusData;
    function toPlutusData(extraDatum) {
      switch (extraDatum.type) {
        case 0 /* NO_DATUM */: {
          return new Constr(extraDatum.type, []);
        }
        case 1 /* DATUM_HASH */: {
          return new Constr(extraDatum.type, [extraDatum.hash]);
        }
        case 2 /* INLINE_DATUM */: {
          return new Constr(extraDatum.type, [extraDatum.hash]);
        }
      }
    }
    ExtraDatum2.toPlutusData = toPlutusData;
  })(ExtraDatum = OrderV22.ExtraDatum || (OrderV22.ExtraDatum = {}));
  ((Datum2) => {
    function fromPlutusData(networkId, data) {
      if (data.index !== 0) {
        throw new Error(`Index of Order Datum must be 0, actual: ${data.index}`);
      }
      const maybeExpiry = data.fields[8];
      let expiry;
      switch (maybeExpiry.index) {
        case 0: {
          expiry = maybeExpiry.fields;
          if (expiry.length !== 2) {
            throw new Error(`Order Expiry list must have 2 elements, actual: ${expiry.length}`);
          }
          break;
        }
        case 1: {
          expiry = void 0;
          break;
        }
        default: {
          throw new Error(`Index of Maybe Expiry must be 0 or 1, actual: ${maybeExpiry.index}`);
        }
      }
      return {
        canceller: AuthorizationMethod.fromPlutusData(data.fields[0]),
        refundReceiver: AddressPlutusData.fromPlutusData(networkId, data.fields[1]),
        refundReceiverDatum: ExtraDatum.fromPlutusData(data.fields[2]),
        successReceiver: AddressPlutusData.fromPlutusData(networkId, data.fields[3]),
        successReceiverDatum: ExtraDatum.fromPlutusData(data.fields[4]),
        lpAsset: Asset.fromPlutusData(data.fields[5]),
        step: Step.fromPlutusData(data.fields[6]),
        maxBatcherFee: data.fields[7],
        expiredOptions: expiry ? {
          expiredTime: expiry[0],
          maxCancellationTip: expiry[1]
        } : void 0
      };
    }
    Datum2.fromPlutusData = fromPlutusData;
    function toPlutusData(datum) {
      return new Constr(0, [
        AuthorizationMethod.toPlutusData(datum.canceller),
        AddressPlutusData.toPlutusData(datum.refundReceiver),
        ExtraDatum.toPlutusData(datum.refundReceiverDatum),
        AddressPlutusData.toPlutusData(datum.successReceiver),
        ExtraDatum.toPlutusData(datum.successReceiverDatum),
        Asset.toPlutusData(datum.lpAsset),
        Step.toPlutusData(datum.step),
        datum.maxBatcherFee,
        datum.expiredOptions ? new Constr(0, [
          datum.expiredOptions.expiredTime,
          datum.expiredOptions.maxCancellationTip
        ]) : new Constr(1, [])
      ]);
    }
    Datum2.toPlutusData = toPlutusData;
  })(OrderV22.Datum || (OrderV22.Datum = {}));
  ((Redeemer2) => {
    Redeemer2[Redeemer2["APPLY_ORDER"] = 0] = "APPLY_ORDER";
    Redeemer2[Redeemer2["CANCEL_ORDER_BY_OWNER"] = 1] = "CANCEL_ORDER_BY_OWNER";
    Redeemer2[Redeemer2["CANCEL_EXPIRED_ORDER_BY_ANYONE"] = 2] = "CANCEL_EXPIRED_ORDER_BY_ANYONE";
  })(OrderV22.Redeemer || (OrderV22.Redeemer = {}));
})(OrderV2 || (OrderV2 = {}));

const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
function sqrt(value) {
  invariant(value >= 0n, "NEGATIVE");
  if (value < MAX_SAFE_INTEGER) {
    return BigInt(Math.floor(Math.sqrt(Number(value))));
  }
  let z;
  let x;
  z = value;
  x = value / 2n + 1n;
  while (x < z) {
    z = x;
    x = (value / x + x) / 2n;
  }
  return z;
}

function calculateSwapExactIn(options) {
  const { amountIn, reserveIn, reserveOut } = options;
  const amtOutNumerator = amountIn * 997n * reserveOut;
  const amtOutDenominator = amountIn * 997n + reserveIn * 1000n;
  const priceImpactNumerator = reserveOut * amountIn * amtOutDenominator * 997n - amtOutNumerator * reserveIn * 1000n;
  const priceImpactDenominator = reserveOut * amountIn * amtOutDenominator * 1000n;
  return {
    amountOut: amtOutNumerator / amtOutDenominator,
    priceImpact: new Big(priceImpactNumerator.toString()).mul(new Big(100)).div(new Big(priceImpactDenominator.toString()))
  };
}
function calculateSwapExactOut(options) {
  const { exactAmountOut, reserveIn, reserveOut } = options;
  const amtInNumerator = reserveIn * exactAmountOut * 1000n;
  const amtInDenominator = (reserveOut - exactAmountOut) * 997n;
  const priceImpactNumerator = reserveOut * amtInNumerator * 997n - exactAmountOut * amtInDenominator * reserveIn * 1000n;
  const priceImpactDenominator = reserveOut * amtInNumerator * 1000n;
  return {
    amountIn: amtInNumerator / amtInDenominator + 1n,
    priceImpact: new Big(priceImpactNumerator.toString()).mul(new Big(100)).div(new Big(priceImpactDenominator.toString()))
  };
}
function calculateDeposit(options) {
  const {
    depositedAmountA,
    depositedAmountB,
    reserveA,
    reserveB,
    totalLiquidity
  } = options;
  const deltaLiquidityA = depositedAmountA * totalLiquidity / reserveA;
  const deltaLiquidityB = depositedAmountB * totalLiquidity / reserveB;
  let necessaryAmountA, necessaryAmountB, lpAmount;
  if (deltaLiquidityA > deltaLiquidityB) {
    necessaryAmountA = depositedAmountB * reserveA / reserveB;
    necessaryAmountB = depositedAmountB;
    lpAmount = deltaLiquidityB;
  } else if (deltaLiquidityA < deltaLiquidityB) {
    necessaryAmountA = depositedAmountA;
    necessaryAmountB = depositedAmountA * reserveB / reserveA;
    lpAmount = deltaLiquidityA;
  } else {
    necessaryAmountA = depositedAmountA;
    necessaryAmountB = depositedAmountB;
    lpAmount = deltaLiquidityA;
  }
  return {
    necessaryAmountA,
    necessaryAmountB,
    lpAmount
  };
}
function calculateWithdraw(options) {
  const { withdrawalLPAmount, reserveA, reserveB, totalLiquidity } = options;
  return {
    amountAReceive: withdrawalLPAmount * reserveA / totalLiquidity,
    amountBReceive: withdrawalLPAmount * reserveB / totalLiquidity
  };
}
function calculateZapIn(options) {
  const { amountIn, reserveIn, reserveOut, totalLiquidity } = options;
  const swapAmountIn = (sqrt(1997n ** 2n * reserveIn ** 2n + 4n * 997n * 1000n * amountIn * reserveIn) - 1997n * reserveIn) / (2n * 997n);
  const swapToAssetOutAmount = calculateSwapExactIn({
    amountIn: swapAmountIn,
    reserveIn,
    reserveOut
  }).amountOut;
  return swapToAssetOutAmount * totalLiquidity / (reserveOut - swapToAssetOutAmount);
}
var DexV2Calculation;
((DexV2Calculation2) => {
  function bigIntPow(x) {
    return x * x;
  }
  DexV2Calculation2.bigIntPow = bigIntPow;
  function calculateInitialLiquidity({
    amountA,
    amountB
  }) {
    let x = sqrt(amountA * amountB);
    if (x * x < amountA * amountB) {
      x += 1n;
    }
    return x;
  }
  DexV2Calculation2.calculateInitialLiquidity = calculateInitialLiquidity;
  function calculateAmountOut({
    reserveIn,
    reserveOut,
    amountIn,
    tradingFeeNumerator
  }) {
    const diff = PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR - tradingFeeNumerator;
    const inWithFee = diff * amountIn;
    const numerator = inWithFee * reserveOut;
    const denominator = PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR * reserveIn + inWithFee;
    return numerator / denominator;
  }
  DexV2Calculation2.calculateAmountOut = calculateAmountOut;
  function calculateAmountOutFraction({
    reserveIn,
    reserveOut,
    amountIn,
    tradingFeeNumerator
  }) {
    const [amountInNumerator, amountInDenominator] = amountIn;
    const diff = PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR - tradingFeeNumerator;
    const numerator = amountInNumerator * diff * reserveOut;
    const denominator = PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR * amountInDenominator * reserveIn + amountInNumerator * diff;
    return [numerator, denominator];
  }
  DexV2Calculation2.calculateAmountOutFraction = calculateAmountOutFraction;
  function calculateAmountIn({
    reserveIn,
    reserveOut,
    amountOut,
    tradingFeeNumerator
  }) {
    if (amountOut >= reserveOut) {
      throw new Error("Amount Out must be less than Reserve Out");
    }
    const diff = PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR - tradingFeeNumerator;
    const numerator = reserveIn * amountOut * PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR;
    const denominator = (reserveOut - amountOut) * diff;
    return numerator / denominator + 1n;
  }
  DexV2Calculation2.calculateAmountIn = calculateAmountIn;
  function calculateMaxInSwap({
    reserveIn,
    reserveOut,
    tradingFeeNumerator,
    ioRatio
  }) {
    const [ioRatioNumerator, ioRatioDenominator] = ioRatio;
    const diff = PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR - tradingFeeNumerator;
    const numerator = ioRatioNumerator * diff * reserveOut - ioRatioDenominator * PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR * reserveIn;
    const denominator = ioRatioDenominator * diff;
    const maxInSwap = numerator / denominator;
    return maxInSwap > 0 ? maxInSwap : 0n;
  }
  DexV2Calculation2.calculateMaxInSwap = calculateMaxInSwap;
  function calculateDepositAmount({
    amountA,
    amountB,
    poolInfo
  }) {
    const { datumReserves, totalLiquidity, tradingFee } = poolInfo;
    const [datumReserveA, datumReserveB] = [...datumReserves];
    const ratioA = amountA * totalLiquidity / datumReserveA;
    const ratioB = amountB * totalLiquidity / datumReserveB;
    if (ratioA > ratioB) {
      const swapAmountA = calculateDepositSwapAmount({
        amountIn: amountA,
        amountOut: amountB,
        reserveIn: datumReserveA,
        reserveOut: datumReserveB,
        tradingFeeNumerator: tradingFee.feeANumerator
      });
      const [swapAmountANumerator, swapAmountADenominator] = swapAmountA;
      const lpAmount = (amountA * swapAmountADenominator - swapAmountANumerator) * totalLiquidity / (datumReserveA * swapAmountADenominator + swapAmountANumerator);
      return lpAmount;
    } else if (ratioA < ratioB) {
      const swapAmountB = calculateDepositSwapAmount({
        amountIn: amountB,
        amountOut: amountA,
        reserveIn: datumReserveB,
        reserveOut: datumReserveA,
        tradingFeeNumerator: tradingFee.feeBNumerator
      });
      const [swapAmountBNumerator, swapAmountBDenominator] = swapAmountB;
      const lpAmount = (amountB * swapAmountBDenominator - swapAmountBNumerator) * totalLiquidity / (datumReserveB * swapAmountBDenominator + swapAmountBNumerator);
      return lpAmount;
    } else {
      return ratioA;
    }
  }
  DexV2Calculation2.calculateDepositAmount = calculateDepositAmount;
  function calculateDepositSwapAmount({
    amountIn,
    amountOut,
    reserveIn,
    reserveOut,
    tradingFeeNumerator
  }) {
    const x = (amountOut + reserveOut) * reserveIn;
    const y = 4n * (amountOut + reserveOut) * (amountOut * reserveIn * reserveIn - amountIn * reserveIn * reserveOut);
    const z = 2n * (amountOut + reserveOut);
    const a = bigIntPow(x) * bigIntPow(2n * PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR - tradingFeeNumerator) - y * PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR * (PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR - tradingFeeNumerator);
    const b = (2n * PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR - tradingFeeNumerator) * x;
    const numerator = sqrt(a) - b;
    const denominator = z * (PoolV2.DEFAULT_TRADING_FEE_DENOMINATOR - tradingFeeNumerator);
    return [numerator, denominator];
  }
  DexV2Calculation2.calculateDepositSwapAmount = calculateDepositSwapAmount;
  function calculateWithdrawAmount({
    withdrawalLPAmount,
    datumReserves,
    totalLiquidity
  }) {
    const [datumReserveA, datumReserveB] = [...datumReserves];
    const amountA = withdrawalLPAmount * datumReserveA / totalLiquidity;
    const amountB = withdrawalLPAmount * datumReserveB / totalLiquidity;
    return {
      withdrawalA: amountA,
      withdrawalB: amountB
    };
  }
  DexV2Calculation2.calculateWithdrawAmount = calculateWithdrawAmount;
  function calculateZapOutAmount({
    withdrawalLPAmount,
    direction,
    poolInfo
  }) {
    const { datumReserves, totalLiquidity, tradingFee } = poolInfo;
    const [datumReserveA, datumReserveB] = [...datumReserves];
    const { withdrawalA, withdrawalB } = calculateWithdrawAmount({
      withdrawalLPAmount,
      datumReserves,
      totalLiquidity
    });
    const reserveAAfterWithdraw = datumReserveA - withdrawalA;
    const reserveBAfterWithdraw = datumReserveB - withdrawalB;
    let amountOut = 0n;
    switch (direction) {
      case OrderV2.Direction.A_TO_B: {
        const extraAmountOut = calculateAmountOut({
          amountIn: withdrawalA,
          reserveIn: reserveAAfterWithdraw,
          reserveOut: reserveBAfterWithdraw,
          tradingFeeNumerator: tradingFee.feeANumerator
        });
        amountOut = withdrawalB + extraAmountOut;
        return amountOut;
      }
      case OrderV2.Direction.B_TO_A: {
        const extraAmountOut = calculateAmountOut({
          amountIn: withdrawalB,
          reserveIn: reserveBAfterWithdraw,
          reserveOut: reserveAAfterWithdraw,
          tradingFeeNumerator: tradingFee.feeBNumerator
        });
        amountOut = withdrawalA + extraAmountOut;
        return amountOut;
      }
    }
  }
  DexV2Calculation2.calculateZapOutAmount = calculateZapOutAmount;
})(DexV2Calculation || (DexV2Calculation = {}));

var DexVersion = /* @__PURE__ */ ((DexVersion2) => {
  DexVersion2["DEX_V1"] = "DEX_V1";
  DexVersion2["DEX_V2"] = "DEX_V2";
  DexVersion2["STABLESWAP"] = "STABLESWAP";
  return DexVersion2;
})(DexVersion || {});

const FIXED_BATCHER_FEE = 2000000n;
function getActiveBatcherFee(networkEnv, dexVersion) {
  const batcherFeeConfig = BATCHER_FEE_CONFIG[networkEnv][dexVersion];
  if (!batcherFeeConfig) {
    return void 0;
  }
  const currentTime = new Date().getTime();
  let activeReductionConfig;
  for (const config of batcherFeeConfig.reduction) {
    const isActive = config.startTime.getTime() <= currentTime && config.endTime ? currentTime <= config.endTime.getTime() : true;
    if (isActive) {
      activeReductionConfig = config;
    }
  }
  return activeReductionConfig;
}
function getReducedBatcherFee(activeReductionConfig, reductionAssets) {
  const totalReductionAmountRatio = new BigNumber(0);
  const { assets, minFee } = activeReductionConfig;
  for (const { asset, maximumAmount } of assets) {
    if (asset in reductionAssets) {
      const reductionAmount = new BigNumber(reductionAssets[asset].toString()).div(maximumAmount.toString());
      totalReductionAmountRatio.plus(reductionAmount);
    }
  }
  const maximumReductionAmountRatio = totalReductionAmountRatio.isGreaterThanOrEqualTo(new BigNumber(1)) ? new BigNumber(1) : totalReductionAmountRatio;
  const maximumReduction = new BigNumber(FIXED_BATCHER_FEE.toString()).minus(minFee.toString()).div(FIXED_BATCHER_FEE.toString()).multipliedBy(100);
  const totalReduction = new BigNumber(maximumReduction).multipliedBy(maximumReductionAmountRatio).div(100);
  const finalFee = new BigNumber(1).minus(totalReduction).multipliedBy(new BigNumber(FIXED_BATCHER_FEE.toString())).toFixed(0);
  return BigInt(finalFee);
}
const BATCHER_FEE_CONFIG = {
  [NetworkEnvironment.MAINNET]: {
    [DexVersion.DEX_V1]: {
      standardFee: 2000000n,
      reduction: [
        {
          minFee: 1500000n,
          startTime: new Date("2022-09-14T07:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c6.4d494e",
              maximumAmount: 50000000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.6aa2153e1ae896a95539c9d62f76cedcdabdcdf144e564b8955f609d660cf6a2",
              maximumAmount: 5000000000n
            }
          ]
        }
      ]
    },
    [DexVersion.STABLESWAP]: {
      standardFee: 2000000n,
      reduction: [
        {
          minFee: 1500000n,
          startTime: new Date("2022-09-14T07:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c6.4d494e",
              maximumAmount: 50000000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.6aa2153e1ae896a95539c9d62f76cedcdabdcdf144e564b8955f609d660cf6a2",
              maximumAmount: 5000000000n
            }
          ]
        }
      ]
    },
    [DexVersion.DEX_V2]: {
      standardFee: 1000000n,
      reduction: [
        {
          minFee: 750000n,
          startTime: new Date("2024-07-01T05:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c6.4d494e",
              maximumAmount: 50000000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.6aa2153e1ae896a95539c9d62f76cedcdabdcdf144e564b8955f609d660cf6a2",
              maximumAmount: 5000000000n
            },
            {
              asset: "f5808c2c990d86da54bfc97d89cee6efa20cd8461616359478d96b4c.82e2b1fd27a7712a1a9cf750dfbea1a5778611b20e06dd6a611df7a643f8cb75",
              maximumAmount: 5000000000n
            }
          ]
        }
      ]
    }
  },
  [NetworkEnvironment.TESTNET_PREPROD]: {
    [DexVersion.DEX_V1]: {
      standardFee: 2000000n,
      reduction: [
        {
          minFee: 1500000n,
          startTime: new Date("2022-09-01T00:00:00.000Z"),
          endTime: new Date("2024-06-24T00:00:00.000Z"),
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            }
          ]
        },
        {
          minFee: 1500000n,
          startTime: new Date("2024-06-24T00:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            },
            {
              asset: "d6aae2059baee188f74917493cf7637e679cd219bdfbbf4dcbeb1d0b.6c3ea488e6ff940bb6fb1b18fd605b5931d9fefde6440117015ba484cf321200",
              maximumAmount: 100000000n
            }
          ]
        }
      ]
    },
    [DexVersion.STABLESWAP]: {
      standardFee: 2000000n,
      reduction: [
        {
          minFee: 1500000n,
          startTime: new Date("2022-09-01T00:00:00.000Z"),
          endTime: new Date("2024-06-24T00:00:00.000Z"),
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            }
          ]
        },
        {
          minFee: 1500000n,
          startTime: new Date("2024-06-24T00:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            },
            {
              asset: "d6aae2059baee188f74917493cf7637e679cd219bdfbbf4dcbeb1d0b.6c3ea488e6ff940bb6fb1b18fd605b5931d9fefde6440117015ba484cf321200",
              maximumAmount: 100000000n
            }
          ]
        }
      ]
    },
    [DexVersion.DEX_V2]: {
      standardFee: 1300000n,
      reduction: [
        {
          minFee: 1000000n,
          startTime: new Date("2024-04-23T00:00:00.000Z"),
          endTime: new Date("2024-06-24T00:00:00.000Z"),
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            }
          ]
        },
        {
          minFee: 1000000n,
          startTime: new Date("2024-06-24T00:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            },
            {
              asset: "d6aae2059baee188f74917493cf7637e679cd219bdfbbf4dcbeb1d0b.6c3ea488e6ff940bb6fb1b18fd605b5931d9fefde6440117015ba484cf321200",
              maximumAmount: 100000000n
            }
          ]
        }
      ]
    }
  },
  [NetworkEnvironment.TESTNET_PREVIEW]: {
    [DexVersion.DEX_V1]: {
      standardFee: 2000000n,
      reduction: [
        {
          minFee: 1500000n,
          startTime: new Date("2022-09-01T00:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            }
          ]
        }
      ]
    },
    [DexVersion.STABLESWAP]: {
      standardFee: 2000000n,
      reduction: [
        {
          minFee: 1500000n,
          startTime: new Date("2022-09-01T00:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            }
          ]
        }
      ]
    },
    [DexVersion.DEX_V2]: {
      standardFee: 1300000n,
      reduction: [
        {
          minFee: 1000000n,
          startTime: new Date("2024-01-01T00:00:00.000Z"),
          endTime: void 0,
          assets: [
            {
              asset: "e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72.4d494e",
              maximumAmount: 10000000n
            },
            {
              asset: "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86.3bb0079303c57812462dec9de8fb867cef8fd3768de7f12c77f6f0dd80381d0d",
              maximumAmount: 100000000n
            }
          ]
        }
      ]
    }
  }
};

function calculateBatcherFee({
  utxos,
  orderAssets,
  dexVersion,
  networkEnv
}) {
  const reductionAssets = {};
  const activeBatcherFeeConfig = getActiveBatcherFee(networkEnv, dexVersion);
  if (!activeBatcherFeeConfig) {
    return {
      batcherFee: FIXED_BATCHER_FEE,
      reductionAssets
    };
  }
  const totalAssets = {};
  for (const u of utxos) {
    for (const [asset, amount] of Object.entries(u.assets)) {
      if (asset in totalAssets) {
        totalAssets[asset] += amount;
      } else {
        totalAssets[asset] = amount;
      }
    }
  }
  const eligibleReductionAssets = {};
  for (const { asset } of activeBatcherFeeConfig.assets) {
    if (asset in totalAssets) {
      eligibleReductionAssets[asset] = totalAssets[asset];
      if (asset in orderAssets) {
        eligibleReductionAssets[asset] -= orderAssets[asset];
      }
    }
  }
  return {
    batcherFee: getReducedBatcherFee(activeBatcherFeeConfig, eligibleReductionAssets),
    reductionAssets
  };
}

function lucidToNetworkEnv(network) {
  if (network === "Mainnet") {
    return NetworkEnvironment.MAINNET;
  } else if (network === "Preprod") {
    return NetworkEnvironment.TESTNET_PREPROD;
  } else if (network === "Preview") {
    return NetworkEnvironment.TESTNET_PREVIEW;
  }
  throw new Error("Not supported");
}

class Dex {
  lucid;
  networkId;
  networkEnv;
  dexVersion = DexVersion.DEX_V1;
  constructor(lucid) {
    this.lucid = lucid;
    this.networkId = lucid.network === "Mainnet" ? NetworkId.MAINNET : NetworkId.TESTNET;
    this.networkEnv = lucidToNetworkEnv(lucid.network);
  }
  async buildSwapExactInTx(options) {
    const {
      sender,
      assetIn,
      amountIn,
      assetOut,
      minimumAmountOut,
      isLimitOrder,
      availableUtxos
    } = options;
    invariant(amountIn > 0n, "amount in must be positive");
    invariant(minimumAmountOut > 0n, "minimum amount out must be positive");
    const orderAssets = { [Asset.toString(assetIn)]: amountIn };
    const { batcherFee, reductionAssets } = calculateBatcherFee({
      utxos: availableUtxos,
      orderAssets,
      networkEnv: this.networkEnv,
      dexVersion: this.dexVersion
    });
    if (orderAssets["lovelace"]) {
      orderAssets["lovelace"] += FIXED_DEPOSIT_ADA + batcherFee;
    } else {
      orderAssets["lovelace"] = FIXED_DEPOSIT_ADA + batcherFee;
    }
    const datum = {
      sender,
      receiver: sender,
      receiverDatumHash: void 0,
      step: {
        type: OrderV1.StepType.SWAP_EXACT_IN,
        desiredAsset: assetOut,
        minimumReceived: minimumAmountOut
      },
      batcherFee,
      depositADA: FIXED_DEPOSIT_ADA
    };
    const tx = this.lucid.newTx().payToContract(DexV1Constant.ORDER_BASE_ADDRESS[this.networkId], Data.to(OrderV1.Datum.toPlutusData(datum)), orderAssets).payToAddress(sender, reductionAssets).addSigner(sender);
    if (isLimitOrder) {
      tx.attachMetadata(674, {
        msg: [MetadataMessage.SWAP_EXACT_IN_LIMIT_ORDER]
      });
    } else {
      tx.attachMetadata(674, { msg: [MetadataMessage.SWAP_EXACT_IN_ORDER] });
    }
    return await tx.complete();
  }
  async buildSwapExactOutTx(options) {
    const {
      sender,
      assetIn,
      assetOut,
      maximumAmountIn,
      expectedAmountOut,
      availableUtxos
    } = options;
    invariant(maximumAmountIn > 0n && expectedAmountOut > 0n, "amount in and out must be positive");
    const orderAssets = { [Asset.toString(assetIn)]: maximumAmountIn };
    const { batcherFee, reductionAssets } = calculateBatcherFee({
      utxos: availableUtxos,
      orderAssets,
      networkEnv: this.networkEnv,
      dexVersion: this.dexVersion
    });
    if (orderAssets["lovelace"]) {
      orderAssets["lovelace"] += FIXED_DEPOSIT_ADA + batcherFee;
    } else {
      orderAssets["lovelace"] = FIXED_DEPOSIT_ADA + batcherFee;
    }
    const datum = {
      sender,
      receiver: sender,
      receiverDatumHash: void 0,
      step: {
        type: OrderV1.StepType.SWAP_EXACT_OUT,
        desiredAsset: assetOut,
        expectedReceived: expectedAmountOut
      },
      batcherFee,
      depositADA: FIXED_DEPOSIT_ADA
    };
    return await this.lucid.newTx().payToContract(DexV1Constant.ORDER_BASE_ADDRESS[this.networkId], Data.to(OrderV1.Datum.toPlutusData(datum)), orderAssets).payToAddress(sender, reductionAssets).addSigner(sender).attachMetadata(674, { msg: [MetadataMessage.SWAP_EXACT_OUT_ORDER] }).complete();
  }
  async buildWithdrawTx(options) {
    const {
      sender,
      lpAsset,
      lpAmount,
      minimumAssetAReceived,
      minimumAssetBReceived,
      availableUtxos
    } = options;
    invariant(lpAmount > 0n, "LP amount must be positive");
    invariant(minimumAssetAReceived > 0n && minimumAssetBReceived > 0n, "minimum asset received must be positive");
    const orderAssets = { [Asset.toString(lpAsset)]: lpAmount };
    const { batcherFee, reductionAssets } = calculateBatcherFee({
      utxos: availableUtxos,
      orderAssets,
      networkEnv: this.networkEnv,
      dexVersion: this.dexVersion
    });
    if (orderAssets["lovelace"]) {
      orderAssets["lovelace"] += FIXED_DEPOSIT_ADA + batcherFee;
    } else {
      orderAssets["lovelace"] = FIXED_DEPOSIT_ADA + batcherFee;
    }
    const datum = {
      sender,
      receiver: sender,
      receiverDatumHash: void 0,
      step: {
        type: OrderV1.StepType.WITHDRAW,
        minimumAssetA: minimumAssetAReceived,
        minimumAssetB: minimumAssetBReceived
      },
      batcherFee,
      depositADA: FIXED_DEPOSIT_ADA
    };
    return await this.lucid.newTx().payToContract(DexV1Constant.ORDER_BASE_ADDRESS[this.networkId], Data.to(OrderV1.Datum.toPlutusData(datum)), orderAssets).payToAddress(sender, reductionAssets).addSigner(sender).attachMetadata(674, { msg: [MetadataMessage.WITHDRAW_ORDER] }).complete();
  }
  async buildZapInTx(options) {
    const {
      sender,
      assetIn,
      amountIn,
      assetOut,
      minimumLPReceived,
      availableUtxos
    } = options;
    invariant(amountIn > 0n, "amount in must be positive");
    invariant(minimumLPReceived > 0n, "minimum LP received must be positive");
    const orderAssets = { [Asset.toString(assetIn)]: amountIn };
    const { batcherFee, reductionAssets } = calculateBatcherFee({
      utxos: availableUtxos,
      orderAssets,
      networkEnv: this.networkEnv,
      dexVersion: this.dexVersion
    });
    if (orderAssets["lovelace"]) {
      orderAssets["lovelace"] += FIXED_DEPOSIT_ADA + batcherFee;
    } else {
      orderAssets["lovelace"] = FIXED_DEPOSIT_ADA + batcherFee;
    }
    const datum = {
      sender,
      receiver: sender,
      receiverDatumHash: void 0,
      step: {
        type: OrderV1.StepType.ZAP_IN,
        desiredAsset: assetOut,
        minimumLP: minimumLPReceived
      },
      batcherFee,
      depositADA: FIXED_DEPOSIT_ADA
    };
    return await this.lucid.newTx().payToContract(DexV1Constant.ORDER_BASE_ADDRESS[this.networkId], Data.to(OrderV1.Datum.toPlutusData(datum)), orderAssets).payToAddress(sender, reductionAssets).addSigner(sender).attachMetadata(674, { msg: [MetadataMessage.ZAP_IN_ORDER] }).complete();
  }
  async buildDepositTx(options) {
    const {
      sender,
      assetA,
      assetB,
      amountA,
      amountB,
      minimumLPReceived,
      availableUtxos
    } = options;
    invariant(amountA > 0n && amountB > 0n, "amount must be positive");
    invariant(minimumLPReceived > 0n, "minimum LP received must be positive");
    const orderAssets = {
      [Asset.toString(assetA)]: amountA,
      [Asset.toString(assetB)]: amountB
    };
    const { batcherFee, reductionAssets } = calculateBatcherFee({
      utxos: availableUtxos,
      orderAssets,
      networkEnv: this.networkEnv,
      dexVersion: this.dexVersion
    });
    if (orderAssets["lovelace"]) {
      orderAssets["lovelace"] += FIXED_DEPOSIT_ADA + batcherFee;
    } else {
      orderAssets["lovelace"] = FIXED_DEPOSIT_ADA + batcherFee;
    }
    const datum = {
      sender,
      receiver: sender,
      receiverDatumHash: void 0,
      step: {
        type: OrderV1.StepType.DEPOSIT,
        minimumLP: minimumLPReceived
      },
      batcherFee,
      depositADA: FIXED_DEPOSIT_ADA
    };
    return await this.lucid.newTx().payToContract(DexV1Constant.ORDER_BASE_ADDRESS[this.networkId], Data.to(OrderV1.Datum.toPlutusData(datum)), orderAssets).payToAddress(sender, reductionAssets).addSigner(sender).attachMetadata(674, { msg: [MetadataMessage.DEPOSIT_ORDER] }).complete();
  }
  async buildCancelOrder(options) {
    const { orderUtxo } = options;
    const redeemer = Data.to(new Constr(OrderV1.Redeemer.CANCEL_ORDER, []));
    const rawDatum = orderUtxo.datum;
    invariant(rawDatum, `Cancel Order requires Order UTxOs along with its CBOR Datum`);
    const orderDatum = OrderV1.Datum.fromPlutusData(this.networkId, Data.from(rawDatum));
    return await this.lucid.newTx().collectFrom([orderUtxo], redeemer).addSigner(orderDatum.sender).attachSpendingValidator(DexV1Constant.ORDER_SCRIPT).attachMetadata(674, { msg: [MetadataMessage.CANCEL_ORDER] }).complete();
  }
}

class DexV2 {
  lucid;
  networkId;
  adapter;
  networkEnv;
  dexVersion = DexVersion.DEX_V2;
  constructor(lucid, adapter) {
    this.lucid = lucid;
    this.networkId = lucid.network === "Mainnet" ? NetworkId.MAINNET : NetworkId.TESTNET;
    this.adapter = adapter;
    this.networkEnv = lucidToNetworkEnv(lucid.network);
  }
  async createPoolTx({
    assetA,
    assetB,
    amountA,
    amountB,
    tradingFeeNumerator
  }) {
    const config = DexV2Constant.CONFIG[this.networkId];
    const [sortedAssetA, sortedAssetB, sortedAmountA, sortedAmountB] = Asset.compare(assetA, assetB) < 0 ? [assetA, assetB, amountA, amountB] : [assetB, assetA, amountB, amountA];
    const factory = await this.adapter.getFactoryV2ByPair(sortedAssetA, sortedAssetB);
    invariant(factory, `cannot find available Factory V2 Utxo, the liquidity pool might be created before`);
    const initialLiquidity = DexV2Calculation.calculateInitialLiquidity({
      amountA: sortedAmountA,
      amountB: sortedAmountB
    });
    const remainingLiquidity = PoolV2.MAX_LIQUIDITY - (initialLiquidity - PoolV2.MINIMUM_LIQUIDITY);
    const lpAssetName = PoolV2.computeLPAssetName(sortedAssetA, sortedAssetB);
    const lpAsset = {
      policyId: config.lpPolicyId,
      tokenName: lpAssetName
    };
    const poolBatchingStakeCredential = this.lucid.utils.getAddressDetails(config.poolBatchingAddress)?.stakeCredential;
    invariant(poolBatchingStakeCredential, `cannot parse Liquidity Pool batching address`);
    const poolDatum = {
      poolBatchingStakeCredential,
      assetA: sortedAssetA,
      assetB: sortedAssetB,
      totalLiquidity: initialLiquidity,
      reserveA: sortedAmountA,
      reserveB: sortedAmountB,
      baseFee: {
        feeANumerator: tradingFeeNumerator,
        feeBNumerator: tradingFeeNumerator
      },
      feeSharingNumerator: void 0,
      allowDynamicFee: false
    };
    const poolValue = {
      lovelace: PoolV2.DEFAULT_POOL_ADA,
      [Asset.toString(lpAsset)]: remainingLiquidity,
      [config.poolAuthenAsset]: 1n
    };
    if (poolValue[Asset.toString(sortedAssetA)]) {
      poolValue[Asset.toString(sortedAssetA)] += sortedAmountA;
    } else {
      poolValue[Asset.toString(sortedAssetA)] = sortedAmountA;
    }
    if (poolValue[Asset.toString(sortedAssetB)]) {
      poolValue[Asset.toString(sortedAssetB)] += sortedAmountB;
    } else {
      poolValue[Asset.toString(sortedAssetB)] = sortedAmountB;
    }
    const deployedScripts = DexV2Constant.DEPLOYED_SCRIPTS[this.networkId];
    const factoryRefs = await this.lucid.utxosByOutRef([
      deployedScripts.factory
    ]);
    invariant(factoryRefs.length === 1, "cannot find deployed script for Factory Validator");
    const factoryRef = factoryRefs[0];
    const authenRefs = await this.lucid.utxosByOutRef([deployedScripts.authen]);
    invariant(authenRefs.length === 1, "cannot find deployed script for Authen Minting Policy");
    const authenRef = authenRefs[0];
    const factoryUtxos = await this.lucid.utxosByOutRef([
      {
        txHash: factory.txIn.txHash,
        outputIndex: factory.txIn.index
      }
    ]);
    invariant(factoryUtxos.length === 1, "cannot find Utxo of Factory");
    const factoryUtxo = factoryUtxos[0];
    const factoryRedeemer = {
      assetA: sortedAssetA,
      assetB: sortedAssetB
    };
    const newFactoryDatum1 = {
      head: factory.head,
      tail: lpAssetName
    };
    const newFactoryDatum2 = {
      head: lpAssetName,
      tail: factory.tail
    };
    return this.lucid.newTx().readFrom([factoryRef, authenRef]).collectFrom([factoryUtxo], Data.to(FactoryV2.Redeemer.toPlutusData(factoryRedeemer))).payToContract(config.poolCreationAddress, {
      inline: Data.to(PoolV2.Datum.toPlutusData(poolDatum))
    }, poolValue).payToContract(config.factoryAddress, {
      inline: Data.to(FactoryV2.Datum.toPlutusData(newFactoryDatum1))
    }, {
      [config.factoryAsset]: 1n
    }).payToContract(config.factoryAddress, {
      inline: Data.to(FactoryV2.Datum.toPlutusData(newFactoryDatum2))
    }, {
      [config.factoryAsset]: 1n
    }).mintAssets({
      [Asset.toString(lpAsset)]: PoolV2.MAX_LIQUIDITY,
      [config.factoryAsset]: 1n,
      [config.poolAuthenAsset]: 1n
    }, Data.to(new Constr(1, []))).attachMetadata(674, { msg: [MetadataMessage.CREATE_POOL] }).complete();
  }
  buildOrderValue(options) {
    const orderAssets = {};
    switch (options.type) {
      case OrderV2.StepType.DEPOSIT: {
        const { assetA, assetB, amountA, amountB, minimumLPReceived } = options;
        invariant(amountA >= 0n && amountB >= 0n && amountA + amountB > 0n, "amount must be positive");
        invariant(minimumLPReceived > 0n, "minimum LP received must be positive");
        orderAssets[Asset.toString(assetA)] = amountA;
        orderAssets[Asset.toString(assetB)] = amountB;
        break;
      }
      case OrderV2.StepType.WITHDRAW: {
        const {
          lpAsset,
          lpAmount,
          minimumAssetAReceived,
          minimumAssetBReceived
        } = options;
        invariant(lpAmount > 0n, "LP amount must be positive");
        invariant(minimumAssetAReceived > 0n && minimumAssetBReceived > 0n, "minimum asset received must be positive");
        orderAssets[Asset.toString(lpAsset)] = lpAmount;
        break;
      }
      case OrderV2.StepType.SWAP_EXACT_IN: {
        const { assetIn, amountIn, minimumAmountOut } = options;
        invariant(amountIn > 0n, "amount in must be positive");
        invariant(minimumAmountOut > 0n, "minimum amount out must be positive");
        orderAssets[Asset.toString(assetIn)] = amountIn;
        break;
      }
      case OrderV2.StepType.SWAP_EXACT_OUT: {
        const { assetIn, maximumAmountIn, expectedReceived } = options;
        invariant(maximumAmountIn > 0n, "amount in must be positive");
        invariant(expectedReceived > 0n, "minimum amount out must be positive");
        orderAssets[Asset.toString(assetIn)] = maximumAmountIn;
        break;
      }
      case OrderV2.StepType.STOP: {
        const { assetIn, amountIn, stopAmount } = options;
        invariant(amountIn > 0n, "amount in must be positive");
        invariant(stopAmount > 0n, "stop amount out must be positive");
        orderAssets[Asset.toString(assetIn)] = amountIn;
        break;
      }
      case OrderV2.StepType.OCO: {
        const { assetIn, amountIn, stopAmount, limitAmount } = options;
        invariant(amountIn > 0n, "amount in must be positive");
        invariant(stopAmount > 0n, "stop amount out must be positive");
        invariant(limitAmount > 0n, "limit amount out must be positive");
        orderAssets[Asset.toString(assetIn)] = amountIn;
        break;
      }
      case OrderV2.StepType.ZAP_OUT: {
        const { lpAsset, lpAmount, minimumReceived } = options;
        invariant(lpAmount > 0n, "lp amount in must be positive");
        invariant(minimumReceived > 0n, "minimum amount out must be positive");
        orderAssets[Asset.toString(lpAsset)] = lpAmount;
        break;
      }
      case OrderV2.StepType.PARTIAL_SWAP: {
        const { assetIn, amountIn, expectedInOutRatio } = options;
        invariant(amountIn > 0n, "amount in must be positive");
        const [expectedInOutRatioNumerator, expectedInOutRatioDenominator] = expectedInOutRatio;
        invariant(expectedInOutRatioNumerator > 0n && expectedInOutRatioDenominator > 0n, "expected input and output ratio must be positive");
        orderAssets[Asset.toString(assetIn)] = amountIn;
        break;
      }
      case OrderV2.StepType.WITHDRAW_IMBALANCE: {
        const { lpAsset, lpAmount, ratioAssetA, ratioAssetB, minimumAssetA } = options;
        invariant(lpAmount > 0n, "LP amount must be positive");
        invariant(ratioAssetA > 0n && ratioAssetB > 0n && minimumAssetA > 0n, "minimum asset and ratio received must be positive");
        orderAssets[Asset.toString(lpAsset)] = lpAmount;
        break;
      }
      case OrderV2.StepType.SWAP_ROUTING: {
        const { assetIn, amountIn } = options;
        invariant(amountIn > 0n, "Amount must be positive");
        orderAssets[Asset.toString(assetIn)] = amountIn;
        break;
      }
    }
    if ("lovelace" in orderAssets) {
      orderAssets["lovelace"] += FIXED_DEPOSIT_ADA;
    } else {
      orderAssets["lovelace"] = FIXED_DEPOSIT_ADA;
    }
    return orderAssets;
  }
  buildOrderStep(options, finalBatcherFee) {
    switch (options.type) {
      case OrderV2.StepType.DEPOSIT: {
        const { amountA, amountB, minimumLPReceived, killOnFailed } = options;
        invariant(amountA >= 0n && amountB >= 0n && amountA + amountB > 0n, "amount must be positive");
        invariant(minimumLPReceived > 0n, "minimum LP received must be positive");
        const orderStep = {
          type: OrderV2.StepType.DEPOSIT,
          depositAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            depositAmountA: amountA,
            depositAmountB: amountB
          },
          minimumLP: minimumLPReceived,
          killable: killOnFailed ? OrderV2.Killable.KILL_ON_FAILED : OrderV2.Killable.PENDING_ON_FAILED
        };
        return orderStep;
      }
      case OrderV2.StepType.WITHDRAW: {
        const {
          lpAmount,
          minimumAssetAReceived,
          minimumAssetBReceived,
          killOnFailed
        } = options;
        invariant(lpAmount > 0n, "LP amount must be positive");
        invariant(minimumAssetAReceived > 0n && minimumAssetBReceived > 0n, "minimum asset received must be positive");
        const orderStep = {
          type: OrderV2.StepType.WITHDRAW,
          withdrawalAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            withdrawalLPAmount: lpAmount
          },
          minimumAssetA: minimumAssetAReceived,
          minimumAssetB: minimumAssetBReceived,
          killable: killOnFailed ? OrderV2.Killable.KILL_ON_FAILED : OrderV2.Killable.PENDING_ON_FAILED
        };
        return orderStep;
      }
      case OrderV2.StepType.SWAP_EXACT_IN: {
        const { amountIn, direction, minimumAmountOut, killOnFailed } = options;
        invariant(amountIn > 0n, "amount in must be positive");
        invariant(minimumAmountOut > 0n, "minimum amount out must be positive");
        const orderStep = {
          type: OrderV2.StepType.SWAP_EXACT_IN,
          direction,
          swapAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            swapAmount: amountIn
          },
          minimumReceived: minimumAmountOut,
          killable: killOnFailed ? OrderV2.Killable.KILL_ON_FAILED : OrderV2.Killable.PENDING_ON_FAILED
        };
        return orderStep;
      }
      case OrderV2.StepType.SWAP_EXACT_OUT: {
        const { maximumAmountIn, expectedReceived, direction, killOnFailed } = options;
        invariant(maximumAmountIn > 0n, "amount in must be positive");
        invariant(expectedReceived > 0n, "minimum amount out must be positive");
        const orderStep = {
          type: OrderV2.StepType.SWAP_EXACT_OUT,
          direction,
          maximumSwapAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            swapAmount: maximumAmountIn
          },
          expectedReceived,
          killable: killOnFailed ? OrderV2.Killable.KILL_ON_FAILED : OrderV2.Killable.PENDING_ON_FAILED
        };
        return orderStep;
      }
      case OrderV2.StepType.STOP: {
        const { amountIn, direction, stopAmount } = options;
        invariant(amountIn > 0n, "amount in must be positive");
        invariant(stopAmount > 0n, "stop amount out must be positive");
        const orderStep = {
          type: OrderV2.StepType.STOP,
          direction,
          swapAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            swapAmount: amountIn
          },
          stopReceived: stopAmount
        };
        return orderStep;
      }
      case OrderV2.StepType.OCO: {
        const { amountIn, direction, stopAmount, limitAmount } = options;
        invariant(amountIn > 0n, "amount in must be positive");
        invariant(stopAmount > 0n, "stop amount out must be positive");
        invariant(limitAmount > 0n, "limit amount out must be positive");
        const orderStep = {
          type: OrderV2.StepType.OCO,
          direction,
          swapAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            swapAmount: amountIn
          },
          stopReceived: stopAmount,
          minimumReceived: limitAmount
        };
        return orderStep;
      }
      case OrderV2.StepType.ZAP_OUT: {
        const { lpAmount, minimumReceived, direction, killOnFailed } = options;
        invariant(lpAmount > 0n, "lp amount in must be positive");
        invariant(minimumReceived > 0n, "minimum amount out must be positive");
        const orderStep = {
          type: OrderV2.StepType.ZAP_OUT,
          direction,
          withdrawalAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            withdrawalLPAmount: lpAmount
          },
          minimumReceived,
          killable: killOnFailed ? OrderV2.Killable.KILL_ON_FAILED : OrderV2.Killable.PENDING_ON_FAILED
        };
        return orderStep;
      }
      case OrderV2.StepType.PARTIAL_SWAP: {
        const {
          amountIn,
          direction,
          expectedInOutRatio,
          maximumSwapTime,
          minimumSwapAmountRequired
        } = options;
        invariant(amountIn > 0n, "amount in must be positive");
        const [expectedInOutRatioNumerator, expectedInOutRatioDenominator] = expectedInOutRatio;
        invariant(expectedInOutRatioNumerator > 0n && expectedInOutRatioDenominator > 0n, "expected input and output ratio must be positive");
        const orderStep = {
          type: OrderV2.StepType.PARTIAL_SWAP,
          direction,
          totalSwapAmount: amountIn,
          ioRatioNumerator: expectedInOutRatioNumerator,
          ioRatioDenominator: expectedInOutRatioDenominator,
          hops: BigInt(maximumSwapTime),
          minimumSwapAmountRequired,
          maxBatcherFeeEachTime: finalBatcherFee
        };
        return orderStep;
      }
      case OrderV2.StepType.WITHDRAW_IMBALANCE: {
        const {
          lpAmount,
          ratioAssetA,
          ratioAssetB,
          minimumAssetA,
          killOnFailed
        } = options;
        invariant(lpAmount > 0n, "LP amount must be positive");
        invariant(ratioAssetA > 0n && ratioAssetB > 0n && minimumAssetA > 0n, "minimum asset and ratio received must be positive");
        const orderStep = {
          type: OrderV2.StepType.WITHDRAW_IMBALANCE,
          withdrawalAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            withdrawalLPAmount: lpAmount
          },
          ratioAssetA,
          ratioAssetB,
          minimumAssetA,
          killable: killOnFailed ? OrderV2.Killable.KILL_ON_FAILED : OrderV2.Killable.PENDING_ON_FAILED
        };
        return orderStep;
      }
      case OrderV2.StepType.SWAP_ROUTING: {
        const { amountIn, routings, minimumReceived } = options;
        invariant(amountIn > 0n, "Amount must be positive");
        const orderStep = {
          type: OrderV2.StepType.SWAP_ROUTING,
          routings,
          swapAmount: {
            type: OrderV2.AmountType.SPECIFIC_AMOUNT,
            swapAmount: amountIn
          },
          minimumReceived
        };
        return orderStep;
      }
    }
  }
  buildOrderAddress(senderAddressStakeCred) {
    const orderAddress = DexV2Constant.CONFIG[this.networkId].orderEnterpriseAddress;
    const orderAddressPaymentCred = this.lucid.utils.getAddressDetails(orderAddress).paymentCredential;
    invariant(orderAddressPaymentCred, "order address payment credentials not found");
    return this.lucid.utils.credentialToAddress(orderAddressPaymentCred, senderAddressStakeCred);
  }
  getOrderScriptHash() {
    const orderAddress = DexV2Constant.CONFIG[this.networkId].orderEnterpriseAddress;
    const addrDetails = this.lucid.utils.getAddressDetails(orderAddress);
    invariant(addrDetails.paymentCredential?.type === "Script", "order address should be a script address");
    return addrDetails.paymentCredential.hash;
  }
  getOrderMetadata(orderOption) {
    switch (orderOption.type) {
      case OrderV2.StepType.SWAP_EXACT_IN: {
        if (orderOption.isLimitOrder) {
          return MetadataMessage.SWAP_EXACT_IN_LIMIT_ORDER;
        } else {
          return MetadataMessage.SWAP_EXACT_IN_ORDER;
        }
      }
      case OrderV2.StepType.STOP: {
        return MetadataMessage.STOP_ORDER;
      }
      case OrderV2.StepType.OCO: {
        return MetadataMessage.OCO_ORDER;
      }
      case OrderV2.StepType.SWAP_EXACT_OUT: {
        return MetadataMessage.SWAP_EXACT_OUT_ORDER;
      }
      case OrderV2.StepType.DEPOSIT: {
        const isZapIn = orderOption.amountA === 0n || orderOption.amountB === 0n;
        if (isZapIn) {
          return MetadataMessage.ZAP_IN_ORDER;
        } else {
          return MetadataMessage.DEPOSIT_ORDER;
        }
      }
      case OrderV2.StepType.WITHDRAW: {
        return MetadataMessage.WITHDRAW_ORDER;
      }
      case OrderV2.StepType.ZAP_OUT: {
        return MetadataMessage.ZAP_OUT_ORDER;
      }
      case OrderV2.StepType.PARTIAL_SWAP: {
        return MetadataMessage.PARTIAL_SWAP_ORDER;
      }
      case OrderV2.StepType.WITHDRAW_IMBALANCE: {
        return MetadataMessage.WITHDRAW_ORDER;
      }
      case OrderV2.StepType.SWAP_ROUTING: {
        return MetadataMessage.ROUTING_ORDER;
      }
    }
  }
  async createBulkOrdersTx({
    sender,
    orderOptions,
    expiredOptions,
    availableUtxos,
    composeTx,
    authorizationMethodType
  }) {
    const totalOrderAssets = {};
    for (const option of orderOptions) {
      const orderAssets = this.buildOrderValue(option);
      for (const [asset, amt] of Object.entries(orderAssets)) {
        if (asset in totalOrderAssets) {
          totalOrderAssets[asset] += amt;
        } else {
          totalOrderAssets[asset] = amt;
        }
      }
    }
    const { batcherFee, reductionAssets } = calculateBatcherFee({
      utxos: availableUtxos,
      orderAssets: totalOrderAssets,
      networkEnv: this.networkEnv,
      dexVersion: this.dexVersion
    });
    const limitOrders = [];
    const lucidTx = this.lucid.newTx();
    for (let i = 0; i < orderOptions.length; i++) {
      const option = orderOptions[i];
      const { type, lpAsset } = option;
      const orderAssets = this.buildOrderValue(option);
      const orderStep = this.buildOrderStep(option, batcherFee);
      if (type === OrderV2.StepType.SWAP_EXACT_IN && option.isLimitOrder) {
        limitOrders.push(i.toString());
      }
      let totalBatcherFee;
      if (type === OrderV2.StepType.PARTIAL_SWAP) {
        totalBatcherFee = batcherFee * BigInt(option.maximumSwapTime);
      } else {
        totalBatcherFee = batcherFee;
      }
      if ("lovelace" in orderAssets) {
        orderAssets["lovelace"] += totalBatcherFee;
      } else {
        orderAssets["lovelace"] = totalBatcherFee;
      }
      const senderPaymentCred = this.lucid.utils.getAddressDetails(sender).paymentCredential;
      invariant(senderPaymentCred, "sender address payment credentials not found");
      const canceller = authorizationMethodType ? {
        type: authorizationMethodType,
        hash: senderPaymentCred.hash
      } : {
        type: OrderV2.AuthorizationMethodType.SIGNATURE,
        hash: senderPaymentCred.hash
      };
      const orderDatum = {
        canceller,
        refundReceiver: sender,
        refundReceiverDatum: {
          type: OrderV2.ExtraDatumType.NO_DATUM
        },
        successReceiver: sender,
        successReceiverDatum: {
          type: OrderV2.ExtraDatumType.NO_DATUM
        },
        step: orderStep,
        lpAsset,
        maxBatcherFee: totalBatcherFee,
        expiredOptions
      };
      let orderAddress;
      try {
        const senderStakeAddress = this.lucid.utils.stakeCredentialOf(sender);
        orderAddress = this.buildOrderAddress(senderStakeAddress);
      } catch (e) {
        orderAddress = DexV2Constant.CONFIG[this.networkId].orderEnterpriseAddress;
      }
      lucidTx.payToContract(orderAddress, {
        inline: Data.to(OrderV2.Datum.toPlutusData(orderDatum))
      }, orderAssets);
    }
    const metadata = orderOptions.length > 1 ? MetadataMessage.MIXED_ORDERS : this.getOrderMetadata(orderOptions[0]);
    const limitOrderMessage = limitOrders.length > 0 ? limitOrders : void 0;
    lucidTx.attachMetadata(674, {
      msg: [metadata],
      limitOrders: limitOrderMessage
    });
    lucidTx.payToAddress(sender, reductionAssets);
    if (composeTx) {
      lucidTx.compose(composeTx);
    }
    return lucidTx.complete();
  }
  async cancelOrder({
    orderOutRefs,
    composeTx
  }) {
    const v2OrderScriptHash = this.getOrderScriptHash();
    const orderUtxos = await this.lucid.utxosByOutRef(orderOutRefs);
    if (orderUtxos.length === 0) {
      throw new Error("Order Utxos are empty");
    }
    const requiredPubKeyHashSet = /* @__PURE__ */ new Set();
    const orderRefs = await this.lucid.utxosByOutRef([
      DexV2Constant.DEPLOYED_SCRIPTS[this.networkId].order
    ]);
    invariant(orderRefs.length === 1, "cannot find deployed script for V2 Order");
    const orderRef = orderRefs[0];
    const lucidTx = this.lucid.newTx().readFrom([orderRef]);
    for (const utxo of orderUtxos) {
      const orderAddr = utxo.address;
      const orderScriptPaymentCred = this.lucid.utils.getAddressDetails(orderAddr).paymentCredential;
      invariant(orderScriptPaymentCred?.type === "Script" && orderScriptPaymentCred.hash === v2OrderScriptHash, `Utxo is not belonged Minswap's order address, utxo: ${utxo.txHash}`);
      let datum;
      if (utxo.datum) {
        const rawDatum = utxo.datum;
        datum = OrderV2.Datum.fromPlutusData(this.networkId, Data.from(rawDatum));
      } else if (utxo.datumHash) {
        const rawDatum = await this.lucid.datumOf(utxo);
        datum = OrderV2.Datum.fromPlutusData(this.networkId, rawDatum);
      } else {
        throw new Error("Utxo without Datum Hash or Inline Datum can not be spent");
      }
      if (datum.canceller.type === OrderV2.AuthorizationMethodType.SIGNATURE)
        requiredPubKeyHashSet.add(datum.canceller.hash);
    }
    const redeemer = Data.to(new Constr(OrderV2.Redeemer.CANCEL_ORDER_BY_OWNER, []));
    lucidTx.collectFrom(orderUtxos, redeemer);
    for (const hash of requiredPubKeyHashSet.keys()) {
      lucidTx.addSignerKey(hash);
    }
    lucidTx.attachMetadata(674, {
      msg: [MetadataMessage.CANCEL_ORDER]
    });
    if (composeTx) {
      lucidTx.compose(composeTx);
    }
    return lucidTx.complete();
  }
}

export { ADA, Asset, BlockfrostAdapter, DEFAULT_POOL_V2_TRADING_FEE_DENOMINATOR, Dex, DexV1Constant, DexV2, DexV2Calculation, DexV2Constant, FIXED_DEPOSIT_ADA, MetadataMessage, NetworkEnvironment, NetworkId, OrderV1, OrderV2, PoolV1, PoolV2, StableOrder, StablePool, StableswapConstant, calculateDeposit, calculateSwapExactIn, calculateSwapExactOut, calculateWithdraw, calculateZapIn };
//# sourceMappingURL=index.es.js.map
